@&#MAIN-TITLE@&#CEPSim: Modelling and simulation of Complex Event Processing systems in cloud environments

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           CEPSim, a simulator for cloud-based Complex Event Processing systems, is proposed.


                        
                        
                           
                           CEPSim query model is based on Directed Acyclic Graphs.


                        
                        
                           
                           CEPSim simulation algorithm is based on a novel abstraction called event sets.


                        
                        
                           
                           Custom operator placement and scheduling algorithms can be used in simulations.


                        
                        
                           
                           Experimental results showed that CEPSim is effective for Big Data simulations.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Complex event processing

Cloud computing

Simulation

Stream processing

Big Data

@&#ABSTRACT@&#


               
               
                  The emergence of Big Data has had profound impacts on how data are stored and processed. As technologies created to process continuous streams of data with low latency, Complex Event Processing (CEP) and Stream Processing (SP) have often been related to the Big Data velocity dimension and used in this context. Many modern CEP and SP systems leverage cloud environments to provide the low latency and scalability required by Big Data applications, yet validating these systems at the required scale is a research problem per se. Cloud computing simulators have been used as a tool to facilitate reproducible and repeatable experiments in clouds. Nevertheless, existing simulators are mostly based on simple application and simulation models that are not appropriate for CEP or for SP. This article presents CEPSim, a simulator for CEP and SP systems in cloud environments. CEPSim proposes a query model based on Directed Acyclic Graphs (DAGs) and introduces a simulation algorithm based on a novel abstraction called event sets. CEPSim is highly customizable and can be used to analyse the performance and scalability of user-defined queries and to evaluate the effects of various query processing strategies. Experimental results show that CEPSim can simulate existing systems in large Big Data scenarios with accuracy and precision.
               
            

@&#INTRODUCTION@&#

The emergence of Big Data has been profoundly changing the way enterprises and organizations store and process data. Clearly, the sheer amount of data created by mobile devices, the Internet of Things (IoT)  [1], and a myriad of other sources cannot be handled by traditional data processing approaches  [2]. Simultaneously, there is also a consensus that obtaining insights and generating knowledge from these Big Data can bring competitive advantage to organizations using them. Therefore, these organizations have been actively pursuing alongside the research community new ways of leveraging Big Data to improve their businesses.

According to the most commonly accepted definition, Big Data is characterized by the 4 Vs  [3]: volume, velocity, variety, and veracity. The velocity dimension refers both to how fast data are generated and how fast they need to be processed. As technologies created to process continuous streams of data with low latency, Complex Event Processing (CEP) and Stream Processing (SP) have often been related to the velocity dimension and applied in the Big Data context. From the business perspective, the goal of these technologies is to process fast input streams, obtain real-time insights, and enable prompt reaction to them  [4].

The resurgence of interest in CEP and SP systems has been accompanied by the use of cloud environments as their runtime platform. Clouds are leveraged to provide the low latency and scalability needed by modern applications  [5–7]. Other systems explore cloud computing to facilitate offering CEP functionalities in the services model  [8]. In this context, the development of efficient operator placement and scheduling strategies are essential to achieve the required quality of service. However, validating these strategies at the required Big Data scale in a cloud environment is a hard problem and constitutes a research problem per se.

First, cloud environments are subject to variations that make it difficult to reproduce the environment and conditions of an experiment  [9]. Moreover, setting up and maintaining large cloud environments are laborious, error-prone, and may be associated with a high financial cost. Finally, there are also many challenges related to generating and storing the volume of data required by Big Data experiments.

Simulators have been used in many different fields to overcome the difficulty of executing repeatable and reproducible experiments. Early research into distributed systems  [10] and grid computing  [11] used simulators, as well as the more recent field of cloud computing  [12–14]. Generally, cloud computing simulators make it possible to model cloud environments and to simulate different workloads running on them. Nonetheless, these simulators are mostly based on application models and simulation algorithms that cannot represent properly the dynamics of CEP or SP systems. To overcome these limitations, this paper presents CEPSim, a flexible simulator of cloud-based CEP and SP systems.


                     CEPSim extends CloudSim   [12] using a query model based on Directed Acyclic Graphs (DAGs) and introduces a simulation algorithm based on a novel abstraction called event sets. CEPSim can be used to model different types of clouds, including public, private, hybrid, and multi-cloud environments, and to simulate execution of user-defined queries on them. In addition, it can also be customized with various operator placement and scheduling strategies. These features enable architects and researchers to analyse the scalability and performance of cloud-based CEP and SP systems and to compare easily the effects of different query processing strategies.

This article significantly extends the authors’ previous work  [15] by improving the discussion about CEPSim’s goals and assumptions, by introducing the event set concept, by presenting detailed descriptions of all simulation algorithms and a thorough evaluation of CEPSim. New experiments include comparing CEPSim with a real SP system in multiple scenarios, assessment of its performance, and a detailed analysis of the available simulation parameters.

The article is structured as follows: Section  2 presents background information and related work. Section  3 discusses the main design principles and assumptions of CEPSim, whereas Sections  4 and 5 detail fundamental concepts and the simulation algorithms. The experimental evaluation is presented in Section  6, and Section  7 is devoted to the final remarks.

@&#RELATED WORK@&#

The basis of Complex Event Processing (CEP) was established by the work of Luckham on Rapide   [10], a distributed system simulator. Later on, the concepts were generalized and applied to the enterprise context in another study by Luckham  [16]. At about the same time, the database community developed the first classical Stream Processing (SP) systems such as Aurora   [17] and STREAM   [18]. CEP and SP technologies share related goals, as both are concerned with processing continuous data flows coming from distributed sources to obtain timely responses to queries  [19]. Because of low-latency processing constraints, CEP and SP are often used in Big Data scenarios in which velocity is the most prominent dimension.

This work uses a terminology based on the Event Processing Technical Society (EPTS) glossary  [20], which originated from the CEP literature. This terminology has been chosen because its terms are broadly defined and encompass most of the SP concepts. Hereafter the CEP term is used as a superset of SP, as defined in the EPTS glossary.

In CEP systems, users create queries (or rules) that specify how to process input event streams and derive “complex events”. These queries have usually been defined by means of proprietary languages such as Aurora Stream Query Algebra (SQuAl)  [17] and CQL  [21].

Despite standardization efforts  [22], a variety of languages are still in use today. Cugola and Margara  [19] classify existing languages into three groups: 
                           
                              •
                              
                                 Declarative: the expected results of the computation are declared, often using a language similar to SQL. The Continuous Query Language (CQL)  [21] is the most prominent representative of this category.


                                 Imperative: the computations to be performed are directly specified using operators that transform event streams. The Aurora Stream Query Algebra (SQuAl)  [17] inspired most languages in this category.


                                 Pattern-based: languages are used to define patterns of events using logical operators, causality relationships, and time constraints. The Rapide   [10] language is an example of this category.

This research uses Directed Acyclic Graphs (DAG) as a language-agnostic representation of CEP queries. More details about the chosen approach are discussed in Section  3.

The recent emergence of cloud computing has been strongly shaping the Big Data landscape. Many authors have recognized the symbiotic relationship between these areas  [23–25], as cloud computing environments can be used to store and process Big Data and also to enable new models for data services. For instance, Chang and Wills  [26] used a cloud platform to store big biomedical data, whereas Grolinger et al.  [27] proposed a platform for knowledge generation and access using cloud technologies.

Current CEP research has been strongly influenced by cloud computing too. For instance, TimeStream   [5], StreamCloud   [6], and StreamHub   [7] are CEP systems that use cloud infrastructures as their runtime environments.

Similarly, the discussion around Big Data, and the rise of the MapReduce platform  [28], have also had a great impact on CEP. The prevalence and success of MapReduce has motivated many researchers to work on systems that leverage its advantages while at the same time try to overcome its limitations when used for low-latency processing. StreamMapReduce   [29] and M3   [30] are examples of MapReduce-inspired systems intended for stream processing. Other frameworks, such as Twitter’s Storm   [31] and Yahoo’s S4   [32], propose a more radical departure from the MapReduce programming model, but maintain runtime platforms inspired by MapReduce implementations.

Simulators are a popular tool that has been used in Grid Computing research  [11,33] for many years. More recently, the usage of simulators in the Cloud Computing field has also become widespread, which motivated the development of a number of simulators such as CloudSim   [12], GreenCloud   [13], and iCanCloud   [14]. None of these, however, can effectively model CEP applications.


                        CloudSim   [12] is a well-known cloud computing simulator that can represent various types of clouds, including private, public, hybrid, and multi-cloud environments. In CloudSim, users define workloads by creating instances of cloudlets, which are submitted and processed by virtual machines (VMs) deployed in the cloud.

Among the most interesting CloudSim features is the customizability of its resource management policies, such as: 
                           
                              •
                              
                                 VM allocation (provisioning): determines how to map a user-requested VM to one of the physical hosts available in a datacentre. Cloud providers normally use strategies that try to maximize the utilization of their servers without violating existing service level agreements (SLA).


                                 VM scheduling: determines how the VMs deployed on a physical host share the available processing elements (PEs). Currently, CloudSim provides two VM scheduling policies: space-shared and time-shared. In the former, each VM has exclusive access to the PEs to which it is allocated, whereas in the latter, VMs share the host PEs by executing on slices of the available processing time.


                                 Cloudlet scheduling: determines how the cloudlets running in a VM share the available VM PEs. Similarly to VM scheduling, both space-shared and time-shared strategies are available.

The major drawback of CloudSim to simulate CEP is its simple application model, which is more appropriate for simulation of batch jobs. Normally, a cloudlet represents an independent finite computation with a length defined by a fixed number of instructions. Moreover, the cloudlet’s internal state other than its expected finish time is invisible. CEP queries, on the other hand, are continuous computations that run indefinitely or for a specific period of time. In addition, tracking queries’ internal state during simulation is essential to analysing any given CEP system. For example, by monitoring the query operators’ queue size, one can determine whether they can keep up with the incoming event rate. The work discussed in this paper circumvents the limited CloudSim application model with a new model based on DAGs, as discussed in Section  4.1.

Because of its limitations, CloudSim has originated many extensions in the literature  [9,34,35]. Garg and Buyya  [9] created NetworkCloudSim, which extends CloudSim with a three-tier network model and an application model that can represent communicating processes. Guérout et al.  [34], on the other hand, focused on implementing the DVFS model on CloudSim. Finally, Grozev and Buyya  [35] presented a model for three-tier Web applications and incorporated it into CloudSim. These extensions are orthogonal to those presented in this paper because they do not focus on CEP.


                        GreenCloud   [13] is a cloud simulator developed as an extension of the NS-2 network simulator  [36]. Therefore, it focuses on packet-level simulation and energy consumption of network equipment, but not on modelling of complex applications.

Finally, the iCanCloud simulator  [14] is similar to CloudSim, but it can also parallelize simulations and has a GUI to interact with the simulator. Its application model, however, is based on low-level primitives and needs to be significantly customized to represent CEP applications. The choice of CloudSim over iCanCloud in this research was motivated by CloudSim’s more mature codebase, the authors’ previous experience, and the larger number of extensions available.


                     CEPSim is a simulator for cloud-based CEP systems that can be used to study the scalability and performance of CEP queries and to compare easily the effects of different query processing strategies. It has been developed with the following design principles as goals: 
                        
                           •
                           
                              Generality: it can simulate different cloud-based CEP systems independently of query definition languages and platform specificities;


                              Extensibility: it can be extended with different operator placement, operator scheduling, and load shedding strategies;


                              Multi-Cloud: it can run simulations that span multiple clouds;


                              Reuse: it can reuse capabilities that are present in CloudSim and comparable simulators.

Because of its maturity and extensibility, CloudSim was chosen as the base cloud simulator on top of which CEPSim was built. Fig. 1
                      shows an overview of CEPSim and how it is related to CloudSim.


                     CloudSim provides the basic simulation framework and two main groups of functionalities: datacentres and policies. The former group includes abstractions used to represent the physical cloud environment, whereas the latter consists of customizable strategies that control the dynamic aspects of the datacentre.


                     CEPSim significantly extends these functionalities to enable simulation of CEP queries. In Fig. 1, these extensions are also organized into two groups: foundation and simulation. The former group contains the fundamental CEPSim abstractions and is detailed in Section  4, whereas the latter implements the CEP simulation logic and is described in Section  5.

To achieve the generality goal, CEPSim assumes that user queries can be transformed into the directed acyclic graph (DAG) format described in Section  4.1. This choice of DAGs as a language-agnostic representation of CEP queries is corroborated by many studies in the literature. For instance, most CEP systems based on imperative languages also use DAGs to represent user queries. This is the case with Aurora   [17], StreamCloud   [6], Storm   [31], S4   [32], FUGU   [37], and many others.

Systems using declarative languages, on the other hand, create execution plans from queries that can often be mapped into DAGs  [5,18]. Even for pattern-based query languages, previous studies  [38] have shown that is possible to transform them into DAGs.

Once transformed, CEPSim assumes that the queries run continuously, processing input events that are constantly pushed into the system. The input streams are expected to be unbounded, but the user must specify for how long the simulation should run.

To simulate distributed (networked) queries, CEPSim’s distribution model assumes that parts of the query DAG are allocated to different VMs and that these VMs can communicate with each other using a network. In addition, CEPSim assumes that multiple queries may be running simultaneously in the same VM and that they can belong to different users.

Finally, CEPSim does not execute any form of single-query or multiple-query optimization because it expects that the submitted queries have already been optimized. Nevertheless, to support these optimizations, CEPSim allows event sources and operators to be shared among queries.

Currently, the main limitation of CEPSim is the fact it only supports scenarios in which the number of simulated queries is fixed and these queries are not reconfigured neither fail at runtime. However, most often this limitation can be circumvented by running and comparing two simulations: one of a scenario before reconfiguration, and another of a scenario after.

This section presents CEPSim foundation concepts on top of which the simulation algorithm is implemented. First it is discussed the CEPSim query model, which is used to define the simulated queries. Then the event set and event set queue abstractions are described.

In CEPSim, each user-defined query 
                           q
                         is represented by a directed acyclic graph (DAG) 
                           
                              
                                 G
                              
                              
                                 q
                              
                           
                           =
                           
                              (
                              
                                 
                                    V
                                 
                                 
                                    q
                                 
                              
                              ,
                              
                                 
                                    E
                                 
                                 
                                    q
                                 
                              
                              )
                           
                        , where each vertex 
                           v
                           ∈
                           
                              
                                 V
                              
                              
                                 q
                              
                           
                         represents a query element and the edges 
                           
                              (
                              u
                              ,
                              v
                              )
                           
                           ∈
                           
                              
                                 E
                              
                              
                                 q
                              
                           
                         represent event streams flowing from an element 
                           u
                         to another element 
                           v
                        . Fig. 2
                         shows an example of a query 
                           q
                        .


                        CEPSim overcomes CloudSim batch application model limitations by using this representation. DAGs can represent complex data processing queries consisting of multiple interconnected steps through which the data flow. In addition, as mentioned in Section  3, most existing query languages can be transformed to DAGs, which emphasizes the generic aspect of this representation.

Vertices from a query 
                           q
                         are further classified into event producers, event consumers, and operators. The set 
                           
                              
                                 V
                              
                              
                                 q
                              
                              
                                 p
                              
                           
                           ⊂
                           
                              
                                 V
                              
                              
                                 q
                              
                           
                         of event producers (event sources) contains all vertices 
                           
                              
                                 v
                              
                              
                                 p
                              
                           
                           ∈
                           
                              
                                 V
                              
                              
                                 q
                              
                           
                         that do not have any incoming edge. These vertices represent the sources of events processed by the query. Conversely, the set 
                           
                              
                                 V
                              
                              
                                 q
                              
                              
                                 c
                              
                           
                           ⊂
                           
                              
                                 V
                              
                              
                                 q
                              
                           
                         of event consumers (event sinks) contains all vertices 
                           
                              
                                 v
                              
                              
                                 c
                              
                           
                           ∈
                           
                              
                                 V
                              
                              
                                 q
                              
                           
                         with no outgoing edges. These vertices are used for the sole purpose of grouping events produced by the query. Finally, the set 
                           
                              
                                 V
                              
                              
                                 q
                              
                              
                                 o
                              
                           
                           ⊂
                           
                              
                                 V
                              
                              
                                 q
                              
                           
                         of operators consists of all vertices that have both incoming and outgoing edges. Operators are pieces of computation that process incoming event streams to produce output streams, and in conjunction they constitute the actual query processing.

Every vertex 
                           v
                           ∈
                           
                              
                                 V
                              
                              
                                 q
                              
                           
                         has a unique identifier (
                           i
                           d
                        ) and an instructions per event (
                           i
                           p
                           e
                        ) attribute, which represents the number of CPU instructions needed to process a single event. For event producers, this attribute estimates the number of instructions required to take an event from the system input and forward it to query execution. In other words, it does not include the effort required to generate the event because event generation does not usually occur within the CEP system.

Every edge 
                           
                              (
                              u
                              ,
                              v
                              )
                           
                           ∈
                           
                              
                                 E
                              
                              
                                 q
                              
                           
                        , on the other hand, has an associated 
                           s
                           e
                           l
                           e
                           c
                           t
                           i
                           v
                           i
                           t
                           y
                         attribute which determines how many of the events processed by 
                           u
                         are actually sent to 
                           v
                        . For example, in Fig. 2, the numbers on the edges represent their selectivity values. Therefore, if 
                           
                              
                                 s
                              
                              
                                 1
                              
                           
                         processes 100 events, 50 will be sent to 
                           
                              
                                 f
                              
                              
                                 1
                              
                           
                         and the other 50 to 
                           
                              
                                 f
                              
                              
                                 2
                              
                           
                         because the selectivity values of both 
                           
                              (
                              
                                 
                                    s
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    f
                                 
                                 
                                    1
                                 
                              
                              )
                           
                         and 
                           
                              (
                              
                                 
                                    s
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    f
                                 
                                 
                                    2
                                 
                              
                              )
                           
                         are 0.5. Note that a selectivity can also be greater than 1 in the case where the operator outputs more than one event based on a single input, e.g., creating two alarms from a single sensor reading.

Hereafter, this article uses the dot notation to refer to query, vertex, and edge attributes. For instance, 
                           v
                           .
                           i
                           d
                         means the 
                           i
                           d
                         attribute of a vertex 
                           v
                        .

To represent CEP queries, CEPSim uses two main operator types: stateless and windowed.

A stateless operator, or simply an operator, can process incoming events in isolation with no dependency on any state computed from previous events. For example, an Aurora filter is an operator that routes events to alternative outputs based on attribute values  [17]. This operator is represented in CEPSim by a stateless operator vertex 
                              o
                              p
                            connected to 
                              n
                            neighbours 
                              o
                              
                                 
                                    p
                                 
                                 
                                    n
                                 
                              
                           , and each edge 
                              
                                 (
                                 o
                                 p
                                 ,
                                 o
                                 
                                    
                                       p
                                    
                                    
                                       n
                                    
                                 
                                 )
                              
                            has a selectivity that determines the percentage of all events processed by 
                              o
                              p
                            that are sent to 
                              o
                              
                                 
                                    p
                                 
                                 
                                    n
                                 
                              
                           .

A windowed operator, on the other hand, is used to simulate operators that process windows of events and combine them in some manner. Typical examples are aggregation operators that count events or calculate the average value of attributes. The behaviour of a windowed operator is determined by three main attributes: a 
                              w
                              i
                              n
                              d
                              o
                              w
                            size, an 
                              a
                              d
                              v
                              a
                              n
                              c
                              e
                            duration, and a 
                              c
                              o
                              m
                              b
                              i
                              n
                              a
                              t
                              i
                              o
                              n
                           
                           
                              f
                              u
                              n
                              c
                              t
                              i
                              o
                              n
                           .


                           Fig. 3
                            illustrates the 
                              w
                              i
                              n
                              d
                              o
                              w
                            and 
                              a
                              d
                              v
                              a
                              n
                              c
                              e
                            concepts. The 
                              w
                              i
                              n
                              d
                              o
                              w
                            specifies the period of time from which the events are taken, and the 
                              a
                              d
                              v
                              a
                              n
                              c
                              e
                            duration defines how the window slides when the previous window closes. Finally, the 
                              c
                              o
                              m
                              b
                              i
                              n
                              a
                              t
                              i
                              o
                              n
                           
                           
                              f
                              u
                              n
                              c
                              t
                              i
                              o
                              n
                            is defined as: 
                              
                                 (1)
                                 
                                    f
                                    :
                                    
                                       
                                          R
                                       
                                       
                                          ≥
                                          0
                                       
                                       
                                          m
                                       
                                    
                                    →
                                    
                                       
                                          R
                                       
                                       
                                          ≥
                                          0
                                       
                                    
                                 
                              
                            where 
                              m
                            is the number of operator predecessors. This function regulates the number of events that are sent to the output given the number of events accumulated in the input. Commonly, it is defined as a constant function 
                              f
                              
                                 (
                                 
                                    
                                       x
                                    
                                    →
                                 
                                 )
                              
                              =
                              1
                           , meaning that for each window, only one event is generated (e.g., for counting events).

Every event producer 
                              p
                            is associated with a generator function 
                              
                                 
                                    g
                                 
                                 
                                    p
                                 
                              
                            that determines the total number of events produced by 
                              p
                            given a point in time. Formally, the generator function is defined as any monotonically increasing function from the time domain to the set of positive integers: 
                              
                                 (2)
                                 
                                    
                                       
                                          g
                                       
                                       
                                          p
                                       
                                    
                                    :
                                    
                                       
                                          R
                                       
                                       
                                          ≥
                                          0
                                       
                                    
                                    →
                                    N
                                    ,
                                    
                                      s.t.  
                                    
                                    x
                                    ≤
                                    y
                                      then  
                                    
                                       
                                          g
                                       
                                       
                                          p
                                       
                                    
                                    
                                       (
                                       x
                                       )
                                    
                                    ≤
                                    
                                       
                                          g
                                       
                                       
                                          p
                                       
                                    
                                    
                                       (
                                       y
                                       )
                                    
                                    .
                                 
                              
                           
                        

An event set is an abstraction that represents a batch of events and is the basic processing unit used by CEPSim. This abstraction has been created to improve the simulator performance and to assist in the calculation of simulation metrics. Operators exchange event sets instead of individual events, and all system queues and temporary buffers are composed of event sets.

Formally, an event set 
                        
                           e
                         is an instance of an 
                           E
                           v
                           e
                           n
                           t
                           S
                           e
                           t
                         class that contains the following attributes: 
                           
                              •
                              
                                 cardinality (cn): number of events in the set. The notation 
                                    
                                       |
                                       e
                                       |
                                    
                                  is also used hereafter as a shortcut for 
                                    e
                                    .
                                    c
                                    n
                                 .


                                 timestamp (ts): a timestamp associated with the set, which can be used for various purposes. Most often, it contains the timestamp at which the set has been created.


                                 latency (lt): the average of the latencies of the events in the set. Event latency is defined as the period of time elapsed from event creation to the moment at which the event is added to the set.


                                 totals (tt): a function that, for each producer 
                                    
                                       
                                          v
                                       
                                       
                                          p
                                       
                                    
                                    ∈
                                    
                                       
                                          V
                                       
                                       
                                          q
                                       
                                       
                                          p
                                       
                                    
                                 , returns the number of events that must have been produced by 
                                    
                                       
                                          v
                                       
                                       
                                          p
                                       
                                    
                                  to originate the events currently in the set. The goal of this attribute is to track caused by (or is result of) relationships between the events in the set and the produced events.

In addition to these attributes, four operations are also defined for event sets: sum, extract, select, and update. 
                           
                              •
                              
                                 Sum: is applied to two event sets 
                                    
                                       
                                          e
                                       
                                       
                                          1
                                       
                                    
                                  and 
                                    
                                       
                                          e
                                       
                                       
                                          2
                                       
                                    
                                  and results in a new event set 
                                    
                                       
                                          e
                                       
                                       
                                          r
                                       
                                    
                                  containing all events from both operands. It is defined as: 
                                    
                                       
                                          (3a)
                                          
                                             
                                                
                                                   e
                                                
                                                
                                                   r
                                                
                                             
                                             =
                                             
                                                
                                                   e
                                                
                                                
                                                   1
                                                
                                             
                                             +
                                             
                                                
                                                   e
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                    
                                  such that 
                                    
                                       
                                          (3b)
                                          
                                             
                                                |
                                                
                                                   
                                                      e
                                                   
                                                   
                                                      r
                                                   
                                                
                                                |
                                             
                                             =
                                             
                                                |
                                                
                                                   
                                                      e
                                                   
                                                   
                                                      1
                                                   
                                                
                                                |
                                             
                                             +
                                             
                                                |
                                                
                                                   
                                                      e
                                                   
                                                   
                                                      2
                                                   
                                                
                                                |
                                             
                                          
                                       
                                       
                                          (3c)
                                          
                                             
                                                
                                                   e
                                                
                                                
                                                   r
                                                
                                             
                                             .
                                             t
                                             s
                                             =
                                             
                                                
                                                   
                                                      |
                                                      
                                                         
                                                            e
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      |
                                                   
                                                   ⋅
                                                   
                                                      
                                                         e
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   .
                                                   t
                                                   s
                                                   +
                                                   
                                                      |
                                                      
                                                         
                                                            e
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      |
                                                   
                                                   ⋅
                                                   
                                                      
                                                         e
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   .
                                                   t
                                                   s
                                                
                                                
                                                   
                                                      |
                                                      
                                                         
                                                            e
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      |
                                                   
                                                   +
                                                   
                                                      |
                                                      
                                                         
                                                            e
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      |
                                                   
                                                
                                             
                                             ,
                                          
                                       
                                       
                                          (3d)
                                          
                                             
                                                
                                                   e
                                                
                                                
                                                   r
                                                
                                             
                                             .
                                             l
                                             t
                                             =
                                             
                                                
                                                   
                                                      |
                                                      
                                                         
                                                            e
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      |
                                                   
                                                   ⋅
                                                   
                                                      
                                                         e
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   .
                                                   l
                                                   t
                                                   +
                                                   
                                                      |
                                                      
                                                         
                                                            e
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      |
                                                   
                                                   ⋅
                                                   
                                                      
                                                         e
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   .
                                                   l
                                                   t
                                                
                                                
                                                   
                                                      |
                                                      
                                                         
                                                            e
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      |
                                                   
                                                   +
                                                   
                                                      |
                                                      
                                                         
                                                            e
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      |
                                                   
                                                
                                             
                                             ,
                                          
                                       
                                       
                                          (3e)
                                          
                                             
                                                
                                                   e
                                                
                                                
                                                   r
                                                
                                             
                                             .
                                             t
                                             t
                                             :
                                             
                                                
                                                   V
                                                
                                                
                                                   q
                                                
                                                
                                                   p
                                                
                                             
                                             →
                                             
                                                
                                                   R
                                                
                                                
                                                   ≥
                                                   0
                                                
                                             
                                             ,
                                             
                                               s.t.  
                                             
                                                
                                                   e
                                                
                                                
                                                   r
                                                
                                             
                                             .
                                             t
                                             t
                                             
                                                (
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      p
                                                   
                                                
                                                )
                                             
                                             =
                                             
                                                
                                                   e
                                                
                                                
                                                   1
                                                
                                             
                                             .
                                             t
                                             t
                                             
                                                (
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      p
                                                   
                                                
                                                )
                                             
                                             +
                                             
                                                
                                                   e
                                                
                                                
                                                   2
                                                
                                             
                                             .
                                             t
                                             t
                                             
                                                (
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      p
                                                   
                                                
                                                )
                                             
                                             .
                                          
                                       
                                    
                                 
                              


                                 Extract: is applied to an event set 
                                    e
                                  and the number of events to be extracted 
                                    n
                                 . The results are an event set 
                                    
                                       
                                          e
                                       
                                       
                                          r
                                       
                                    
                                  consisting of the extracted events, and an event set 
                                    
                                       
                                          e
                                       
                                       
                                          m
                                       
                                    
                                  containing the remaining events from 
                                    e
                                 : 
                                    
                                       
                                          (4a)
                                          
                                             
                                                (
                                                
                                                   
                                                      e
                                                   
                                                   
                                                      r
                                                   
                                                
                                                ,
                                                
                                                   
                                                      e
                                                   
                                                   
                                                      m
                                                   
                                                
                                                )
                                             
                                             =
                                             e
                                             −
                                             n
                                          
                                       
                                    
                                  such that 
                                    
                                       
                                          (4b)
                                          
                                             
                                                |
                                                
                                                   
                                                      e
                                                   
                                                   
                                                      r
                                                   
                                                
                                                |
                                             
                                             =
                                             n
                                          
                                       
                                       
                                          (4c)
                                          
                                             
                                                
                                                   e
                                                
                                                
                                                   r
                                                
                                             
                                             .
                                             t
                                             t
                                             :
                                             
                                                
                                                   V
                                                
                                                
                                                   q
                                                
                                                
                                                   p
                                                
                                             
                                             →
                                             
                                                
                                                   R
                                                
                                                
                                                   ≥
                                                   0
                                                
                                             
                                             ,
                                             
                                               s.t.  
                                             
                                                
                                                   e
                                                
                                                
                                                   r
                                                
                                             
                                             .
                                             t
                                             t
                                             
                                                (
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      p
                                                   
                                                
                                                )
                                             
                                             =
                                             
                                                (
                                                n
                                                /
                                                
                                                   |
                                                   e
                                                   |
                                                
                                                )
                                             
                                             ⋅
                                             e
                                             .
                                             t
                                             t
                                             
                                                (
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      p
                                                   
                                                
                                                )
                                             
                                          
                                       
                                       
                                          (4d)
                                          
                                             
                                                |
                                                
                                                   
                                                      e
                                                   
                                                   
                                                      m
                                                   
                                                
                                                |
                                             
                                             =
                                             
                                                |
                                                e
                                                |
                                             
                                             −
                                             n
                                          
                                       
                                       
                                          (4e)
                                          
                                             
                                                
                                                   e
                                                
                                                
                                                   m
                                                
                                             
                                             .
                                             t
                                             t
                                             :
                                             
                                                
                                                   V
                                                
                                                
                                                   q
                                                
                                                
                                                   p
                                                
                                             
                                             →
                                             
                                                
                                                   R
                                                
                                                
                                                   ≥
                                                   0
                                                
                                             
                                             ,
                                             
                                               s.t.  
                                          
                                       
                                       
                                          (4f)
                                          
                                             
                                                
                                                   e
                                                
                                                
                                                   m
                                                
                                             
                                             .
                                             t
                                             t
                                             
                                                (
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      p
                                                   
                                                
                                                )
                                             
                                             =
                                             e
                                             .
                                             t
                                             t
                                             
                                                (
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      p
                                                   
                                                
                                                )
                                             
                                             −
                                             
                                                
                                                   e
                                                
                                                
                                                   r
                                                
                                             
                                             .
                                             t
                                             t
                                             
                                                (
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      p
                                                   
                                                
                                                )
                                             
                                          
                                       
                                    
                                  and the latency and timestamp attributes from 
                                    
                                       
                                          e
                                       
                                       
                                          r
                                       
                                    
                                  and 
                                    
                                       
                                          e
                                       
                                       
                                          m
                                       
                                    
                                  are the same as in 
                                    e
                                 .


                                 Select: is applied to an event set 
                                    e
                                  and a selectivity 
                                    s
                                 . It selects a subset of events from the event set: 
                                    
                                       
                                          (5a)
                                          
                                             
                                                
                                                   e
                                                
                                                
                                                   r
                                                
                                             
                                             =
                                             e
                                             ∗
                                             s
                                          
                                       
                                    
                                  such that 
                                    
                                       (5b)
                                       
                                          
                                             |
                                             
                                                
                                                   e
                                                
                                                
                                                   r
                                                
                                             
                                             |
                                          
                                          =
                                          
                                             |
                                             e
                                             |
                                          
                                          ⋅
                                          s
                                          .
                                       
                                    
                                 
                              


                                 Update: is applied to an event set 
                                    e
                                  and a timestamp 
                                    t
                                    s
                                 . It simply brings the event set latency and timestamp up to date: 
                                    
                                       
                                          (6a)
                                          
                                             
                                                
                                                   e
                                                
                                                
                                                   r
                                                
                                             
                                             =
                                             u
                                             p
                                             d
                                             a
                                             t
                                             e
                                             
                                                (
                                                e
                                                ,
                                                t
                                                s
                                                )
                                             
                                          
                                       
                                    
                                  such that 
                                    
                                       
                                          (6b)
                                          
                                             
                                                
                                                   e
                                                
                                                
                                                   r
                                                
                                             
                                             .
                                             t
                                             s
                                             =
                                             t
                                             s
                                          
                                       
                                       
                                          (6c)
                                          
                                             
                                                
                                                   e
                                                
                                                
                                                   r
                                                
                                             
                                             .
                                             l
                                             t
                                             =
                                             e
                                             .
                                             l
                                             t
                                             +
                                             
                                                (
                                                t
                                                s
                                                −
                                                e
                                                .
                                                t
                                                s
                                                )
                                             
                                             .
                                          
                                       
                                    
                                 
                              

An event set queue is simply a queue where the elements are event sets. As with any regular queue, it is possible to enqueue and dequeue elements in a first-in, first-out manner. In addition, an event set queue has an overload 
                           d
                           e
                           q
                           u
                           e
                           u
                           e
                         operation that receives the number of events to be extracted and returns an event set representing these events.

Finally, an event set queue 
                           Q
                         also has a cardinality defined as the sum of the cardinalities of all event sets in the queue: 
                           
                              (7)
                              
                                 
                                    |
                                    Q
                                    |
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       e
                                       ∈
                                       Q
                                    
                                 
                                 
                                    |
                                    e
                                    |
                                 
                                 .
                              
                           
                        
                     

This section presents the CEP simulation logic implemented by CEPSim. First it is discussed the role of operator placement and scheduling strategies in the simulation. Then the simulation procedures are presented both at operator and at placement level. Finally, it is described how CEPSim implements metric calculation.

Once the queries are modelled, the next step in any simulation is to define a set of placements. Each placement maps a set of query vertices to the VM where they will execute. Note that the vertices from a single query can be mapped to more than one VM, which implies distributed query execution. A placement can also contain vertices from more than one query, indicating that the VM is shared among queries. Fig. 4
                         illustrates the placement concept: 
                           P
                           l
                           a
                           c
                           e
                           m
                           e
                           n
                           
                              
                                 t
                              
                              
                                 1
                              
                           
                         maps all vertices from 
                           Q
                           u
                           e
                           r
                           
                              
                                 y
                              
                              
                                 1
                              
                           
                         and some from 
                           Q
                           u
                           e
                           r
                           
                              
                                 y
                              
                              
                                 2
                              
                           
                         to 
                           V
                           
                              
                                 m
                              
                              
                                 1
                              
                           
                        , whereas 
                           P
                           l
                           a
                           c
                           e
                           m
                           e
                           n
                           
                              
                                 t
                              
                              
                                 2
                              
                           
                         maps the remaining 
                           Q
                           u
                           e
                           r
                           
                              
                                 y
                              
                              
                                 2
                              
                           
                         vertices to 
                           V
                           
                              
                                 m
                              
                              
                                 2
                              
                           
                        .

Defining placements for a set of queries is an instance of the operator placement problem, as defined by Lakshmanan et al.  [39]. This mapping is one of the most determining factors of a CEP system performance. Because of this importance, CEPSim is pluggable and enables the use of different placement strategies. By default, users must manually specify the mapping of vertices to VMs when submitting a query to CEPSim.


                        Operator scheduling is the procedure that, given a set of running queries and their internal state, defines which operator should run next and for how long it should run. A scheduling strategy can fundamentally determine the performance of a CEP system by optimizing for different aspects of the system, such as overall QoS  [17] or memory consumption  [40]. Because of this significance, CEPSim also allows different scheduling strategies to be plugged in and used during a simulation.


                        CEPSim contains two built-in scheduling strategies, and both are based on an auxiliary allocation strategy. In this context, the allocation strategy divides the available instructions among the placement vertices, whereas the scheduling strategy determines how the vertices are traversed and how the allocated instructions are used.

The two allocation strategy implementations provided by CEPSim are: 
                           
                              •
                              
                                 Uniform allocation: divide the available instructions equally among all placement vertices;


                                 Weighted allocation: divide the available instructions proportionally to the 
                                    i
                                    p
                                    e
                                  attribute of each vertex.

These two strategies can be combined with the provided scheduling strategies, which work as follows: 
                           
                              •
                              
                                 Simple scheduling: the vertices are sorted in topological order and traversed once according to this order. Each vertex receives the number of instructions determined by the allocation strategy, independently of the number of instructions required.


                                 Dynamic scheduling: the vertices are sorted in topological order and traversed in one or more rounds. In each round, each vertex receives the minimum between the number of instructions determined by the allocation strategy and the number of instructions required to process all input events. The process is repeated until there are no more instructions left to be allocated or events to be processed. This strategy tries to redirect non-used instructions to overloaded vertices and thereby improve query throughput.

In CEPSim, the simulation of an operator execution is accomplished by reading event sets from the operator’s input queues, processing them, and writing output event sets to its output queues. The general procedure used to simulate an operator execution is detailed in Algorithm 1.


                        
                           
                              
                           
                        
                     

The algorithm operates in three main steps: 
                           
                              1.
                              
                                 Lines 2–6: Calculates the number of input events that can be processed. This number is the minimum between the total number of events in all input queues and the maximum number of events that can be processed given the number of allocated instructions 
                                    n
                                 . This maximum is obtained by dividing 
                                    n
                                  by the operator 
                                    i
                                    p
                                    e
                                  attribute.


                                 Lines 7–11: Dequeues events from the input queues and builds a new event set 
                                    e
                                  representing the dequeued events. The number of events dequeued from each input queue is proportional to its size. This procedure aims to balance the queues by processing more events from queues with more elements.


                                 Lines 12–16: Enqueues the recently created event set 
                                    e
                                  into the operator output queues. While enqueuing, the selectivity value of the edge connecting the operator to each of its successors 
                                    
                                       
                                          v
                                       
                                       
                                          s
                                       
                                    
                                  is taken into consideration.

Event producers and consumers are simulated in a similar way. Because event producers do not have predecessor vertices, the input events are read from the generator associated with them. Event consumers, on the other hand, do not have output queues. The processed events are accumulated into a single 
                           o
                           u
                           t
                           p
                           u
                           t
                         event set that consolidates all events consumed during the simulation.

Simulating windowed operators is different because output events are generated only when a window closes. In addition, whenever a window does not close, the input events must be correctly processed and accumulated.

Algorithm 2 describes the simulation procedure of a windowed operator 
                           w
                        . To implement the simulation, every windowed operator has an auxiliary data structure that is used to accumulate the processed events. Fig. 5
                         shows an example of a windowed operator and its corresponding data structure.


                        
                           
                              
                           
                        
                     

The data structure works as a circular array divided into 
                           l
                         slots, on which each slot represents a timeframe equivalent to one advance period within the time window. For example, the windowed operator from Fig. 5(a) has a window size of 30 s and an advance period of 10 s, resulting in an array of size 3. Initially, slots 0, 1, and 2 represent the intervals between 0–10, 10–20, and 20–30 s respectively. Each position of this array contains one event set for each operator predecessor (
                           
                              
                                 p
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 p
                              
                              
                                 2
                              
                           
                        ). These event sets accumulate events coming from the predecessors during the slot period.

To use this data structure, the windowed operator maintains two auxiliary variables, 
                           i
                           n
                           d
                           e
                           x
                         and 
                           n
                           e
                           x
                           t
                        . The 
                           i
                           n
                           d
                           e
                           x
                         variable points to the slot where the accumulation should currently take place, whereas 
                           n
                           e
                           x
                           t
                         stores the next timestamp at which the window closes.

These variables are primarily used between lines 2 and 8 of Algorithm 2. First, when a window closes, an auxiliary procedure 
                           g
                           e
                           n
                           e
                           r
                           a
                           t
                           e
                           O
                           u
                           t
                           p
                           u
                           t
                         is invoked to generate the output event set (Algorithm 3). Then the 
                           n
                           e
                           x
                           t
                         and 
                           i
                           n
                           d
                           e
                           x
                         variables are adjusted, and the next slot is reset. Note that this loop can be executed more than once if more than one window has been closed since the last simulation.

The following lines (9–18) are similar to the stateless operator simulation presented in Algorithm 1, but instead of writing the processed event sets into the output queues, they are accumulated at the current time slot.

The last part of the windowed operator simulation is the 
                           g
                           e
                           n
                           e
                           r
                           a
                           t
                           e
                           O
                           u
                           t
                           p
                           u
                           t
                         procedure shown in Algorithm 3. The loop between lines 4 and 11 builds an event set for each predecessor and a sum of these event sets 
                           s
                           u
                           
                              
                                 m
                              
                              
                                 t
                              
                           
                        . This step is also shown in Fig. 5(b), in which 
                           s
                           u
                           m
                           
                              (
                              
                                 
                                    p
                                 
                                 
                                    1
                                 
                              
                              )
                           
                         is calculated as 
                           
                              
                                 e
                              
                              
                                 1
                              
                           
                           +
                           
                              
                                 e
                              
                              
                                 3
                              
                           
                           +
                           
                              
                                 e
                              
                              
                                 5
                              
                           
                        , 
                           s
                           u
                           m
                           
                              (
                              
                                 
                                    p
                                 
                                 
                                    2
                                 
                              
                              )
                           
                         as 
                           
                              
                                 e
                              
                              
                                 2
                              
                           
                           +
                           
                              
                                 e
                              
                              
                                 4
                              
                           
                           +
                           
                              
                                 e
                              
                              
                                 6
                              
                           
                        , and 
                           s
                           u
                           
                              
                                 m
                              
                              
                                 t
                              
                           
                         is the sum of 
                           s
                           u
                           m
                           
                              (
                              
                                 
                                    p
                                 
                                 
                                    1
                                 
                              
                              )
                           
                         and 
                           s
                           u
                           m
                           
                              (
                              
                                 
                                    p
                                 
                                 
                                    2
                                 
                              
                              )
                           
                        .

From lines 12 to 16, the output event set 
                           o
                           u
                           t
                         is built according to the idea that this event set is caused by, or is a result of, all events accumulated in the window: 
                           
                              
                           
                        
                     


                        
                           
                              •
                              
                                 cardinality (
                                    o
                                    u
                                    t
                                    .
                                    c
                                    n
                                 ) is set to the result of the combination function 
                                    f
                                 . This function receives as argument a set of event sets, each one encapsulating all events received from each specific predecessor 
                                    
                                       
                                          v
                                       
                                       
                                          p
                                       
                                    
                                  during the window timeframe, and returns the number of events that must be generated.


                                 latency (
                                    o
                                    u
                                    t
                                    .
                                    l
                                    t
                                 ) is set to the average latency of all events in the window (
                                    s
                                    u
                                    
                                       
                                          m
                                       
                                       
                                          t
                                       
                                    
                                    .
                                    l
                                    t
                                 ) plus their average waiting time. The waiting time is calculated as the difference between the current timestamp (
                                    t
                                    s
                                 ) and the average timestamp of all events in the window (
                                    s
                                    u
                                    
                                       
                                          m
                                       
                                       
                                          t
                                       
                                    
                                    .
                                    t
                                    s
                                 ).


                                 timestamp (
                                    o
                                    u
                                    t
                                    .
                                    t
                                    s
                                 ) is set to the current timestamp.


                                 totals (
                                    o
                                    u
                                    t
                                    .
                                    t
                                    t
                                 ) is set to the sum of all totals from the event sets in the current slot only, as events in previous slots have already been considered in past windows.

After describing how CEPSim simulates operators, this subsection focuses on the algorithm used to simulate queries. A pseudo-code description of this procedure is presented in Algorithm 4.

The first thing to notice is that the basic unit of simulation is a placement, not a query, which implies that all vertices allocated to a VM are simulated at once. This approach enables operator scheduling strategies to consider simultaneously all vertices in a VM and potentially make better decisions regarding their scheduling optimization criteria.

This procedure simulates execution of a placement for the duration of a simulation tick. As shown in Fig. 6
                        , the CloudSim simulation framework repeatedly invokes this procedure to represent the passing of time. Therefore, the simulation tick length is a parameter that enables users to trade off precision against computational cost. For example, if the tick is long, the procedure will be invoked fewer times, but the produced events will be grouped into relatively large event sets and processed as such. On the other hand, a shorter tick translates into smaller event sets and potentially more precise results.

The following parameters are required by the procedure: a pre-allocated number of instructions 
                           n
                        , the simulation time at which the procedure has been invoked 
                           t
                           s
                        , and the CPU capacity 
                           c
                           p
                         (measured in MIPS) available to the placement. The CloudSim simulation framework determines these arguments at each invocation: first, a cloudlet scheduler calculates 
                           c
                           p
                         by distributing the total CPU processing power among all processes concurrently running on the VM. In Fig. 6, the placement 
                           
                              
                                 p
                              
                              
                                 1
                              
                           
                         has only 
                           c
                           
                              
                                 p
                              
                              
                                 1
                              
                           
                         MIPS available because it shares the same VM with two cloudlets 
                           
                              
                                 c
                              
                              
                                 2
                              
                           
                         and 
                           
                              
                                 c
                              
                              
                                 3
                              
                           
                        . Then the number of instructions 
                           n
                         is derived by multiplying the available capacity 
                           c
                           p
                         by the simulation tick length. In Fig. 6, the value of 
                           n
                         is equivalent to the area encompassed by each process.


                        
                           
                              
                           
                        
                     

In summary, there are three main steps in Algorithm 4: 
                           
                              1.
                              All generators associated with the placement event producers are activated to determine the number of events that have been generated from the last simulation tick to the current one (lines 2–4);

The scheduling strategy associated with the placement is invoked to define the order in which the vertices will be simulated and the number of instructions allocated to each vertex (line 5).

All vertices are traversed and simulated according to the specified order (lines 6–15). The scheduling strategy returns an iterator of pairs, each one containing a vertex pointer (
                                    n
                                    e
                                    x
                                    t
                                    .
                                    v
                                 ) and the number of instructions allocated to the vertex (
                                    n
                                    e
                                    x
                                    t
                                    .
                                    n
                                 ). With these two parameters, the operator simulation procedure is invoked (line 9). Then the current timestamp 
                                    t
                                    s
                                  is adjusted to reproduce the passing of time (line 10). Finally, the event sets in each of the vertex output queues are moved to the input queues of their respective successors (lines 11–14).

To simulate networked (distributed) queries, the CEPSim placement simulation from Algorithm 4 received two main modifications.

First, at the moment that event sets are moved from the operator output queues to the input queues of its successors (lines 11–14), the algorithm checks whether the successor vertex belongs to the same placement or not. If it does, the event set is moved to the destination queue as usual. If it does not, then the event set and the destination vertex id are sent to a network interface, which executes three main steps: 
                              
                                 1.
                                 Locate the placement where the successor vertex resides by consulting the 
                                       C
                                       e
                                       p
                                       S
                                       i
                                       m
                                       B
                                       r
                                       o
                                       k
                                       e
                                       r
                                     (implementation details can be examined in  Appendix A).

Calculate the delay in transferring the event set to the destination VM. This calculation depends on the network interface implementation in use.

Schedule a simulation event on the destination VM signalling the arrival of the event set. This event is scheduled using the simulation framework provided by CloudSim.

The second modification is in the main loop between lines 6 and 15. Before each iteration, the algorithm checks whether any simulation event (representing the arrival of an event set) is scheduled during the operator time slice. If one is, the time slice is split in two at the event set arrival time, and the event set is enqueued into its destination queue between the two slices.

This procedure is illustrated in Fig. 7
                           . In the query from Fig. 7(a), vertices 
                              
                                 
                                    p
                                 
                                 
                                    3
                                 
                              
                           , 
                              
                                 
                                    f
                                 
                                 
                                    3
                                 
                              
                           , and 
                              
                                 
                                    f
                                 
                                 
                                    4
                                 
                              
                            are placed into one VM, and the remaining vertices are placed into another. The diagram in Fig. 7(b) shows the placements schedule as a function of time. At the end of the first iteration, vertex 
                              
                                 
                                    f
                                 
                                 
                                    4
                                 
                              
                            “sends” an event set to its successor 
                              
                                 
                                    m
                                 
                                 
                                    3
                                 
                              
                           . This step is represented by scheduling a simulation event on the destination placement after the period of time required to transfer the event set from 
                              
                                 
                                    f
                                 
                                 
                                    4
                                 
                              
                            to 
                              
                                 
                                    m
                                 
                                 
                                    3
                                 
                              
                           . In the second iteration, the algorithm detects the scheduled event before starting the 
                              
                                 
                                    m
                                 
                                 
                                    3
                                 
                              
                            simulation. Then the 
                              
                                 
                                    m
                                 
                                 
                                    3
                                 
                              
                            time slice is split into two halves (
                              
                                 
                                    m
                                 
                                 
                                    3
                                 
                                 
                                    ′
                                 
                              
                            and 
                              
                                 
                                    m
                                 
                                 
                                    3
                                 
                                 
                                    ″
                                 
                              
                           ), and the event set is enqueued right after 
                              
                                 
                                    m
                                 
                                 
                                    3
                                 
                                 
                                    ′
                                 
                              
                            finishes.

Most CEP systems limit the size of operator queues to avoid memory overflow and to maintain overall system performance. Because of this characteristic, CEPSim also supports the definition of bounded input operator queues. When using this feature, it is necessary to define the behaviour of the system when new events arrive at an already full queue. Currently, CEPSim supports the application of backpressure to vertex predecessors.

When using backpressure, operators inform their predecessors about the maximum number of events accepted for the next iteration at the end of its simulation procedure. Then, the predecessors limit their output on the next tick if needed. Nevertheless, when an operator limits its output, it may also accumulate events in its own input queues and consequently apply backpressure to its set of predecessors. Ultimately, the backpressure arrives at the event producers, which may choose to discard extraneous events or accumulate them in their own queues.

One of the most important parts of any simulator is the set of metrics obtained as a result of the simulation. As CEP queries performance are usually measured in terms of its latency and throughput, CEPSim provides built-in implementations for these two metrics.

The query latency metric is defined for each consumer 
                           
                              
                                 v
                              
                              
                                 c
                              
                           
                         as the average number of seconds elapsed from the moment an event arrives at the query to the moment it is consumed by 
                           
                              
                                 v
                              
                              
                                 c
                              
                           
                        . In other words, it measures how long a query takes to process an event. Conversely, the query throughput metric of a consumer 
                           
                              
                                 v
                              
                              
                                 c
                              
                           
                         is the average number of events processed per second during its lifespan. Therefore, it quantifies the rate at which events are processed. In CEPSim, both metrics can be easily obtained because every event consumer has an 
                           o
                           u
                           t
                           p
                           u
                           t
                         event set that accumulates all events that have been consumed during a simulation.

Formally, the value of 
                           l
                           a
                           t
                           e
                           n
                           c
                           y
                           
                              (
                              
                                 
                                    v
                                 
                                 
                                    c
                                 
                              
                              )
                           
                         is simply the latency of 
                           
                              
                                 v
                              
                              
                                 c
                              
                           
                           
                           o
                           u
                           t
                           p
                           u
                           t
                         event set: 
                           
                              (8)
                              
                                 l
                                 a
                                 t
                                 e
                                 n
                                 c
                                 y
                                 
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          c
                                       
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       v
                                    
                                    
                                       c
                                    
                                 
                                 .
                                 o
                                 u
                                 t
                                 p
                                 u
                                 t
                                 .
                                 l
                                 t
                                 .
                              
                           
                         The calculation of 
                           t
                           h
                           r
                           o
                           u
                           g
                           h
                           p
                           u
                           t
                           
                              (
                              
                                 
                                    v
                                 
                                 
                                    c
                                 
                              
                              )
                           
                        , on the other hand, is based on the 
                           t
                           o
                           t
                           a
                           l
                           s
                         attribute of the 
                           o
                           u
                           t
                           p
                           u
                           t
                         event set. This attribute contains the total number of events generated by each producer that have resulted in the events in the set. Thus, the throughput can be obtained by summing the values for all producers and dividing this sum by the query simulation time (in seconds). However, if there is more than one path from a producer 
                           
                              
                                 v
                              
                              
                                 p
                              
                           
                         to the consumer 
                           
                              
                                 v
                              
                              
                                 c
                              
                           
                        , the 
                           o
                           u
                           t
                           p
                           u
                           t
                         event set contains duplicates incorporated into the 
                           t
                           o
                           t
                           a
                           l
                           s
                         values for 
                           
                              
                                 v
                              
                              
                                 p
                              
                           
                         and needs to be fixed. Therefore, the query throughput of a consumer 
                           
                              
                                 v
                              
                              
                                 c
                              
                           
                         is formally given by: 
                           
                              (9)
                              
                                 t
                                 h
                                 r
                                 o
                                 u
                                 g
                                 h
                                 p
                                 u
                                 t
                                 
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          c
                                       
                                    
                                    )
                                 
                                 =
                                 
                                    (
                                    
                                       
                                          ∑
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                p
                                             
                                          
                                          ∈
                                          
                                             
                                                V
                                             
                                             
                                                q
                                             
                                             
                                                p
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                v
                                             
                                             
                                                c
                                             
                                          
                                          .
                                          o
                                          u
                                          t
                                          p
                                          u
                                          t
                                          .
                                          t
                                          t
                                          
                                             (
                                             
                                                
                                                   v
                                                
                                                
                                                   p
                                                
                                             
                                             )
                                          
                                       
                                       
                                          
                                             |
                                             p
                                             a
                                             t
                                             h
                                             s
                                             
                                                (
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      p
                                                   
                                                
                                                ,
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      c
                                                   
                                                
                                                )
                                             
                                             |
                                          
                                       
                                    
                                    )
                                 
                                 /
                                 q
                                 .
                                 t
                                 i
                                 m
                                 e
                              
                           
                         where 
                           
                              |
                              p
                              a
                              t
                              h
                              s
                              
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       p
                                    
                                 
                                 ,
                                 
                                    
                                       v
                                    
                                    
                                       c
                                    
                                 
                                 )
                              
                              |
                           
                         is the number of paths from producer 
                           
                              
                                 v
                              
                              
                                 p
                              
                           
                         to consumer 
                           
                              
                                 v
                              
                              
                                 c
                              
                           
                         and 
                           q
                           .
                           t
                           i
                           m
                           e
                         is the total query simulation time.


                        Fig. 8
                         exemplifies how the event sets are created and updated during a simulation tick until they are accumulated into the event consumer. The event sets 
                           
                              
                                 e
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 e
                              
                              
                                 2
                              
                           
                         were generated at timestamp 
                           t
                           s
                           =
                           5
                        . At 
                           t
                           s
                           =
                           10
                         the producer 
                           
                              
                                 p
                              
                              
                                 1
                              
                           
                         sends 
                           
                              
                                 e
                              
                              
                                 1
                              
                           
                         to 
                           
                              
                                 f
                              
                              
                                 1
                              
                           
                        , and at 
                           t
                           s
                           =
                           13
                         producer 
                           
                              
                                 p
                              
                              
                                 2
                              
                           
                         sends 
                           
                              
                                 e
                              
                              
                                 2
                              
                           
                         to 
                           
                              
                                 f
                              
                              
                                 1
                              
                           
                        . Note that 
                           
                              
                                 e
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 e
                              
                              
                                 2
                              
                           
                         attributes are updated to take into account the time elapsed from the event set generation to the moment they are output. When processed by 
                           
                              
                                 f
                              
                              
                                 1
                              
                           
                        , both event sets are summed according to Eq. (3a), resulting in a new event set 
                           
                              
                                 e
                              
                              
                                 12
                              
                           
                        . At 
                           t
                           s
                           =
                           15
                        , a new event set 
                           
                              
                                 e
                              
                              
                                 3
                              
                           
                         is created by updating 
                           
                              
                                 e
                              
                              
                                 12
                              
                           
                         timestamp and applying 
                           
                              (
                              
                                 
                                    f
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    f
                                 
                                 
                                    2
                                 
                              
                              )
                           
                         selectivity to it: 
                           
                              (10)
                              
                                 
                                    
                                       e
                                    
                                    
                                       3
                                    
                                 
                                 =
                                 u
                                 p
                                 d
                                 a
                                 t
                                 e
                                 
                                    (
                                    
                                       
                                          e
                                       
                                       
                                          12
                                       
                                    
                                    ,
                                    t
                                    s
                                    )
                                 
                                 ∗
                                 
                                    (
                                    
                                       
                                          f
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          f
                                       
                                       
                                          2
                                       
                                    
                                    )
                                 
                                 .
                                 s
                                 e
                                 l
                                 e
                                 c
                                 t
                                 i
                                 v
                                 i
                                 t
                                 y
                                 .
                              
                           
                         Then the 
                           
                              
                                 e
                              
                              
                                 3
                              
                           
                         event set is sent to 
                           
                              
                                 f
                              
                              
                                 2
                              
                           
                        , where a similar procedure is executed and a new event set 
                           
                              
                                 e
                              
                              
                                 4
                              
                           
                         is created. Finally, 
                           
                              
                                 e
                              
                              
                                 4
                              
                           
                         is sent to the consumer 
                           
                              
                                 c
                              
                              
                                 1
                              
                           
                        , where the final event set 
                           
                              
                                 e
                              
                              
                                 5
                              
                           
                         is created and added to the 
                           o
                           u
                           t
                           p
                           u
                           t
                         event set.

@&#EXPERIMENTS@&#

This section describes the experiments that have been performed to analyse the CEPSim simulator. First, CEPSim is validated by comparing the latency and throughput metrics obtained by running queries on a real CEP/SP system and by simulating them on CEPSim. Then, the simulator performance is assessed by analysing the execution time and memory consumption of various simulation scenarios. Finally, it is also investigated the effects of different parameters on the simulator behaviour.

The queries used in the experiments in this section have been extracted from Powersmiths’ WOW system  [41], a sustainability management platform that draws on live measurements of buildings to support energy management. Powersmiths’ WOW uses Apache Storm  [31] to process in near real-time sensor readings coming from buildings managed by the platform.

Apache Storm is an open-source distributed stream processing system that has been adopted by many enterprises, despite limitations regarding QoS maintenance, privacy, and security  [42]. Note, however, that Storm is still a young product and many researchers are working to overcome its problems. For instance, Aniello et al.  [43] proposed a scheduler that can be used to improve the system performance, and Chang et al.  [44] introduced CCAF, a security framework that can be used to secure Storm deployments.


                        Fig. 9
                         shows the Storm queries (topologies) used in the experiments. A spout in the Storm terminology is equivalent to an event producer, whereas a bolt is equivalent to an operator. There is no concept analogous to an event consumer in Storm.

There are three main steps in the query 
                           
                              
                                 q
                              
                              
                                 1
                              
                           
                         from Fig. 9(a): the 
                           O
                           u
                           t
                           l
                           i
                           e
                           r
                           D
                           e
                           t
                           e
                           c
                           t
                           o
                           r
                           B
                           o
                           l
                           t
                         detects and filters anomalous sensor readings, the 
                           R
                           e
                           a
                           d
                           i
                           n
                           g
                           A
                           v
                           e
                           r
                           a
                           g
                           e
                           B
                           o
                           l
                           t
                         groups readings into windows of 15 s and calculates the average, and the 
                           D
                           B
                           C
                           o
                           n
                           s
                           u
                           m
                           e
                           r
                           B
                           o
                           l
                           t
                         stores the calculated average in a database. By aggregating the sensor data into 15 s windows, the query reduces the amount of data that is written to the database.

The query 
                           
                              
                                 q
                              
                              
                                 2
                              
                           
                         presented in Fig. 9(b), on the other hand, is used to convert from a data format (JSON) to the native WOW format (XML). This query is used because some existing sensors cannot be modified to send data according to the WOW interface. The query is composed of three main steps: the 
                           J
                           s
                           o
                           n
                           P
                           a
                           r
                           s
                           e
                           r
                           B
                           o
                           l
                           t
                         parses the JSON request, the 
                           V
                           a
                           l
                           i
                           d
                           a
                           t
                           e
                           R
                           e
                           a
                           d
                           i
                           n
                           g
                           B
                           o
                           l
                           t
                         validates the request values, and the 
                           X
                           m
                           l
                           O
                           u
                           t
                           p
                           u
                           t
                           B
                           o
                           l
                           t
                         converts the request to XML format. The last bolt (
                           L
                           a
                           t
                           e
                           n
                           c
                           y
                           M
                           e
                           a
                           s
                           u
                           r
                           e
                           r
                           B
                           o
                           l
                           t
                        ) is used only to measure the latency and throughput of the conversion process.


                        Table 1
                         describes the cluster of virtual machines used in the experiments to run Storm topologies. All six VMs were deployed on the same physical server (12 cores Intel Xeon E5-2630, 2.6 GHz/96 GB RAM). VMs #1 and #2 run zookeeper (which coordinates cluster communication) and nimbus (which assigns Storm tasks to workers). The workers VMs #3–#6 are the ones which effectively execute the queries. The VM memory sizes have been dimensioned to not be a bottleneck in the experiments. A similar physical server hosted the database system and was used to run all CEPSim simulations described in the experiments.

The software used in the experiments is presented in Table 2
                        . All Storm topologies have been implemented using Storm’s Java API and use standard Java libraries for database access and XML processing.

Before any simulation, the Storm queries had to be implemented in the CEPSim model. The mapping of Storm queries to CEPSim is straightforward because both use DAGs as their underlying query model.


                        Fig. 10
                         depicts the CEPSim model of both queries presented in the use case section. Each edge connecting two vertices is annotated with its corresponding selectivity, and each vertex is annotated with the estimated 
                           i
                           p
                           e
                         attribute. Storm’s spouts and bolts are mapped to event producer and operator vertices respectively. In both queries, an event consumer is also added to group the events consumed by the query.

To estimate the operator’s 
                           i
                           p
                           e
                         attribute, two methods have been used: 
                           
                              •
                              
                                 Latency estimation: the operator is fed with random events at increasing rates and the average processing time (in milliseconds) is calculated for each rate value. The minimum average is assumed to be the operator latency 
                                    o
                                    
                                       
                                          p
                                       
                                       
                                          l
                                       
                                    
                                 . Then the 
                                    i
                                    p
                                    e
                                  attribute is calculated as: 
                                    
                                       (11)
                                       
                                          o
                                          p
                                          .
                                          i
                                          p
                                          e
                                          =
                                          
                                             (
                                             c
                                             p
                                             
                                                
                                                   u
                                                
                                                
                                                   m
                                                
                                             
                                             ⋅
                                             
                                                
                                                   10
                                                
                                                
                                                   6
                                                
                                             
                                             )
                                          
                                          /
                                          
                                             (
                                             
                                                
                                                   1000
                                                
                                                
                                                   o
                                                   
                                                      
                                                         p
                                                      
                                                      
                                                         l
                                                      
                                                   
                                                
                                             
                                             )
                                          
                                       
                                    
                                  where 
                                    c
                                    p
                                    
                                       
                                          u
                                       
                                       
                                          m
                                       
                                    
                                  is the CPU processing power estimated in MIPS.


                                 Maximum throughput estimation: the maximum throughput 
                                    o
                                    
                                       
                                          p
                                       
                                       
                                          t
                                       
                                    
                                  is estimated by feeding the operator process with as many events as possible. Then the 
                                    i
                                    p
                                    e
                                  attribute is estimated as: 
                                    
                                       (12)
                                       
                                          o
                                          p
                                          .
                                          i
                                          p
                                          e
                                          =
                                          
                                             (
                                             c
                                             p
                                             
                                                
                                                   u
                                                
                                                
                                                   m
                                                
                                             
                                             ⋅
                                             
                                                
                                                   10
                                                
                                                
                                                   6
                                                
                                             
                                             )
                                          
                                          /
                                          o
                                          
                                             
                                                p
                                             
                                             
                                                t
                                             
                                          
                                          .
                                       
                                    
                                 
                              

The first step in CEPSim validation was to unit test all components and to execute a set of sanity checks to detect programming bugs and inconsistent behaviour. After this phase, a set of experiments was executed aiming to compare the performance metrics obtained by running queries on a real CEP/SP system (Apache Storm) and by simulating them on CEPSim. This validation approach is similar to the ones adopted by other simulators, such as NetworkCloudSim  [9], iCanCloud  [14], and Grozev and Buyya  [35].

In all simulations, CEPSim was used to create an environment as close as possible to the Storm VM cluster. Table 3
                         summarizes the main parameters used in the simulations. VMs have been modelled as having two processors, even though only one physical processor was allocated for each. This was done because the processors used in the experiments are hyper-threaded, which enables a higher degree of parallelism than regular processors. The queue size was set to 2048 because by default Storm has buffers with 1024 elements at both the output and input of each operator, but in CEPSim, accumulation happens only at the operators’ input queues.

This first experiment validates CEPSim simulation of a single query running entirely on a single VM.

To obtain the Storm metrics, both queries from Fig. 9 were first instrumented to output the average throughput and latency every minute. In addition, the query 
                              S
                              p
                              o
                              u
                              t
                           s (event producers) were modified so that the user could define the number of sensors 
                              n
                            that send data to the query. Each sensor generates 10 sensor readings per second, of which 5% are anomalies.

The graphs from the experiments were obtained by varying the number of sensors 
                              n
                           , which consequently varied the number of events generated per second. For each 
                              n
                           , the queries were run for 15 min and the average latency (throughput) for each of the last 10 min were collected. Note that each data point is an observation from a sampling distribution of the average query latency (throughput). CEPSim results were obtained using a similar procedure. The graphs show the mean value of these averages and their 99% confidence interval (in other words, the confidence interval of the sampling distribution). In most cases, the confidence interval is small and actually not visible.


                           Fig. 11
                            shows query 
                              
                                 
                                    q
                                 
                                 
                                    1
                                 
                              
                            latency and throughput as a function of the input rate. Generally speaking, CEPSim achieved very high accuracy for both metrics when compared to Storm. The latency error was less than 1% up to 1000 events/s and was kept below 7.5% up to 20,000 events/s. The throughput calculation was even more accurate, with almost no error up to 20,000 events/s.

The major estimation error occurred at 22,500 events/s, at which point the latency obtained by CEPSim was lower than the real value. Further analysis showed that at this point, the Storm query overloaded, and its behaviour became very unpredictable, as can be seen in the high variance of the data point. Nevertheless, CEPSim still correctly predicted the maximum query throughput around 21,000 events/s, as shown in the throughput drop in Fig. 11(b).

Results for the latency and throughput of query 
                              
                                 
                                    q
                                 
                                 
                                    2
                                 
                              
                            are shown in Fig. 12
                           . The latency axis in Fig. 12(a) has a log scale because the measured values encompass five orders of magnitude. Once again, the throughput calculation exhibited very small error, and the maximum query throughput was closely estimated at approximately 21,000 events/s.

The latency at slow input rates showed some error because it is extremely hard to estimate latency accurately at sub-millisecond precision. At 100 events/s, the simulation values approached those obtained with Storm and remained close up to the overload point at 22,500 events/s. After this point, the simulation latency plateaued, whereas the Storm value spiked. This difference was caused mainly by the way that CEPSim handles full queues by using backpressure and discarding generated events. Storm, on the other hand, delays generation of events, but does not discard them.

This experiment aimed to validate CEPSim simulation of distributed queries. To perform this experiment, the query from Fig. 9(a) was distributed into two VMs, such that the 
                              D
                              B
                              C
                              o
                              n
                              s
                              u
                              m
                              e
                              r
                              B
                              o
                              l
                              t
                            was placed into the 
                              w
                              o
                              r
                              k
                              e
                              r
                              2
                            server and all remaining vertices into 
                              w
                              o
                              r
                              k
                              e
                              r
                              1
                           .

A constant delay network interface was used to simulate this query. In this network implementation, every event set sent through the network takes a fixed amount of time to arrive at its destination. This is a reasonable approximation because all VMs run on the same physical server and no real network traffic is being generated. The delay has been estimated as 1 ms in a separate experiment. Furthermore, a simulation tick length of 10 ms was used to improve the simulation precision (see discussion on Section  6.6.2).


                           Fig. 13
                           
                            shows the simulated latency and throughput were very accurate and precise. The latency error was less than 7% up to 27,500 events/s. At 30,000 events/s, the Storm query started to overload and the error increased, but the CEPSim results remained within the confidence interval. The throughput calculation, on the other hand, had no error throughout the experiment.

This experiment analysed CEPSim’s behaviour when simulating multiple queries running concurrently. To do so, first a Storm cluster was created at the Amazon EC2 service  [45]. The setup was similar to the one presented in Table 1, but all VMs were configured as instances of the m4.large type (2 vCPUs and 8 GB of RAM).

Then, four placement strategies were compared in a scenario where four copies of query 
                              
                                 
                                    q
                                 
                                 
                                    1
                                 
                              
                            were simultaneously run: 
                              
                                 1.
                                 
                                    
                                       P
                                       l
                                       a
                                       c
                                       e
                                       m
                                       e
                                       n
                                       
                                          
                                             t
                                          
                                          
                                             1
                                          
                                       
                                    : one VM, with all four queries placed on it;


                                    
                                       P
                                       l
                                       a
                                       c
                                       e
                                       m
                                       e
                                       n
                                       
                                          
                                             t
                                          
                                          
                                             2
                                          
                                       
                                    : two VMs, with two queries placed on each;


                                    
                                       P
                                       l
                                       a
                                       c
                                       e
                                       m
                                       e
                                       n
                                       
                                          
                                             t
                                          
                                          
                                             3
                                          
                                       
                                    : two VMs, with all four instances of 
                                       D
                                       B
                                       C
                                       o
                                       n
                                       s
                                       u
                                       m
                                       e
                                       r
                                       B
                                       o
                                       l
                                       t
                                     placed on one VM and the remaining bolts on the other;


                                    
                                       P
                                       l
                                       a
                                       c
                                       e
                                       m
                                       e
                                       n
                                       
                                          
                                             t
                                          
                                          
                                             4
                                          
                                       
                                    : four VMs, with one query placed on each.

To avoid possible bottlenecks in the database server, 
                              D
                              B
                              C
                              o
                              n
                              s
                              u
                              m
                              e
                              r
                              B
                              o
                              l
                              t
                            was replaced by a mock implementation which does not access the database, but spins in a busy loop for 4.5 ms (the average time spent to process a single event, as measured by the methodology described in Section  6.3).


                           Table 4
                            presents the average latency of all four queries for both Apache Storm and CEPSim. The CEPSim column also shows the relative estimation error. Each query was set up to process 10,000 events/s. The throughput metric has been omitted from the table because it was correctly measured as 10,000 events/s in all scenarios. The results from this experiment demonstrated that CEPSim can accurately simulate multiple queries running on the same VM and can be used to analyse different placement strategies. For instance, the experiment showed that running two instances of query 
                              
                                 
                                    q
                                 
                                 
                                    1
                                 
                              
                            on the same VM does not greatly affect their performance, as illustrated by the small latency increase from 
                              P
                              l
                              a
                              c
                              e
                              m
                              e
                              n
                              
                                 
                                    t
                                 
                                 
                                    4
                                 
                              
                            to 
                              P
                              l
                              a
                              c
                              e
                              m
                              e
                              n
                              
                                 
                                    t
                                 
                                 
                                    2
                                 
                              
                           . It is also clear from 
                              P
                              l
                              a
                              c
                              e
                              m
                              e
                              n
                              
                                 
                                    t
                                 
                                 
                                    1
                                 
                              
                           ’s latency that placing four queries on the same VM can overload it and may not be a good option depending on the users’ QoS requirements.

This section presents two experiments that measure the execution time and memory consumption of CEPSim simulations.


                        Figs. 14(a) and 14(b) depict the results from the first experiment. This experiment simulated a single VM running 
                           n
                         instances of query 
                           
                              
                                 q
                              
                              
                                 2
                              
                           
                         from Fig. 9(b). The simulation time was set to 5 min and each query processed 100 events/s. For each value of 
                           n
                        , the simulation was executed 10 times and the total execution time and memory consumption were recorded. The graphs show the average of these values alongside the 99% confidence interval. CEPSim was able to simulate 100 queries in approximately 7 s and using less than 40 MB of memory. Furthermore, both metrics grew sub-linearly as a function of the number of queries.

The results from the second experiment are shown in Fig. 15
                        . In this experiment, each VM ran a fixed number of queries, and the number of VMs in the datacentre was varied. The graphs show results for two different combinations. In the first, the number of queries per VM was set to 10 and the number of VMs varied from 10 to 1000; in the second, the number of queries per VM was set to 100 and the number of VMs varied from 1 to 100. Both combinations resulted in the same number of total queries, but enabled comparison of the effects of different query placements on CEPSim performance.

The results for the two combinations were very similar. The maximum simulation time was approximately 7 min for a total of 10,000 queries, which translates to 1 million events per second. Less than one 1 GB of memory was needed to run this simulation. Once again, both execution time and memory consumption scaled sub-linearly. This behaviour is expected as long as the available RAM is larger than the memory required by the simulation.

The two experiments described in this section aim to evaluate the effects of different parameters in the simulations. First, it is analysed how scheduling and allocation strategies affect the simulation metrics. Then, the effects of simulation tick length on CEPSim is assessed.

To analyse the effects of operator scheduling strategies, query 
                              
                                 
                                    q
                                 
                                 
                                    1
                                 
                              
                            latency and throughput were estimated using the default and dynamic scheduling strategies combined with the uniform and weighted allocation strategies. Fig. 16
                            summarizes the results obtained when query input rate was configured to 100, 500, and 10,000 events/s.

When the default scheduling strategy was used in high input rate scenarios, the throughput was considerably underestimated and the latency overestimated. This occurred mainly because 
                              D
                              B
                              C
                              o
                              n
                              s
                              u
                              m
                              e
                              r
                              B
                              o
                              l
                              t
                            was scheduled at every simulation tick, even though it receives events only when its predecessor 
                              R
                              e
                              a
                              d
                              i
                              n
                              g
                              A
                              v
                              e
                              r
                              a
                              g
                              e
                              B
                              o
                              l
                              t
                            window closes. This problem was even more pronounced when weighted allocation was used. In this case, the number of instructions that 
                              D
                              B
                              C
                              o
                              n
                              s
                              u
                              m
                              e
                              r
                              B
                              o
                              l
                              t
                            received was proportional to its 
                              i
                              p
                              e
                           , which is much higher than the other operators’ 
                              i
                              p
                              e
                           s.

When using dynamic scheduling strategy, CEPSim better approximated Apache Storm’s results in all scenarios. Nevertheless, when used with weighted allocation, dynamic scheduling underestimated the average latency in the 10,000 events/s case. In this combination, the dynamic strategy prioritized 
                              D
                              B
                              C
                              o
                              n
                              s
                              u
                              m
                              e
                              r
                              B
                              o
                              l
                              t
                            whenever there were events on its input queues, resulting in lower latency at the cost of lower maximum throughput.

To evaluate the effects of simulation tick length on CEPSim, query 
                              q
                              1
                            was simulated using different simulation tick lengths in both local and networked cases. The results are summarized in Table 5
                           . The latency column shows the metric value obtained by the simulation. The execution time column displays the average of 10 simulations, each one including 100 instances of the query running for 5 min.

The results show that the simulation tick length enables users to adjust the trade-off between precision and computational cost. A longer tick introduced estimation error for both scenarios, but the execution time was significantly reduced. The error was more pronounced in the networked query case because of the way network communication is implemented in CEPSim: if a message is sent to a placement that has already been scheduled, then the message will be processed on the next simulation tick only.

@&#DISCUSSION@&#

The experimental results described in this section showed that CEPSim can effectively model real CEP/SP queries and simulate them in a cloud environment. Execution time measurements also demonstrated that CEPSim has excellent performance, being able to simulate 100 queries running for 5 min in 7 s only.

One of the main CEPSim use cases is to understand query behaviour at various input event rates. The experiments described in Sections  6.4.1 and 6.4.2 showed that this study can be performed using CEPSim with relatively good accuracy and precision for both distributed and non-distributed queries and for both high and low input rate scenarios.

As another important use case, the experiments described in Section  6.4.3 showed that CEPSim can also be used to simulate multiple queries running on the same VM. The latency estimation error was kept fairly low during the experiment and enabled easy comparison of different operator placement strategies.

The limitations showed by CEPSim to simulate query 
                           
                              
                                 q
                              
                              
                                 1
                              
                           
                         at the maximum input rate highlighted the difficulty of simulating a system in an overloaded state. Further analysis concluded that, at this point, most of the query latency consisted of I/O waiting time, as the 
                           D
                           B
                           C
                           o
                           n
                           s
                           u
                           m
                           e
                           r
                           B
                           o
                           l
                           t
                         writes to the database every event it receives. In this situation, the operating system continues to schedule other threads and processes, which can continue to process events on their turns. CEPSim uses a simplified model in which operator latency is caused by processing time spent on a CPU only. In addition, the metric calculation errors at high input rates were also caused by differences in the strategy adopted to control the query load: while CEPSim uses backpressure, Storm follows a pull strategy on which events are requested from the producer only when there is space available at the operator queues.

As a final observation, it is claimed that CEPSim can be efficiently used for Big Data simulations. Results from the experiments in Section  6.5 demonstrated that the simulator can scale well and can handle large numbers of queries with a small memory footprint. In addition, CEPSim customizability also enables the user to fine control the simulation by changing parameters such as the simulation tick length and scheduling strategy. Moreover, even though Storm has not been stressed at a larger scale, most experimental results are also applicable to these scenarios. This is true because, in practice, the distribution of Storm (and other CEP systems) queries is limited to a few nodes. In other words, distinct VMs usually run independent pieces of computation that can be simulated in isolation from others.

@&#CONCLUSIONS@&#

This article has presented CEPSim, a simulator for cloud-based Complex Event Processing systems. CEPSim can model different CEP systems by transforming user queries into a Directed Acyclic Graph representation. The modelled queries can be simulated on different environments, including private, public, hybrid, and multi-clouds. In addition, CEPSim also allows customization of operator placement and scheduling strategies, as well as the queue size and data generation functions used during simulation.

Experimental results have shown that CEPSim can simulate a large number of queries running on a large number of virtual machines within a reasonable time and with a very small memory footprint. Furthermore, the experiments also demonstrated that CEPSim can model a real CEP system (Apache Storm) with good accuracy and precision. Together, these results validated CEPSim as an effective tool for simulation of cloud-based CEP systems in Big Data scenarios.

By using CEPSim, architects and researchers can quickly experiment with different configurations and query processing strategies and analyse the performance and scalability of CEP systems. Hopefully, the availability of a simulator may also encourage research in this field.

In future work, it is planned to add reconfiguration features to CEPSim, including dynamically moving vertices to other VMs and deploying new queries during a simulation. Moreover, experiments that simultaneously use multiple clouds will also be included.

@&#ACKNOWLEDGEMENTS@&#

This research was supported in part by an NSERC CRD at Western University (CRDPJ 453294-13). Additionally, the authors would like to acknowledge the support provided by Powersmiths.

This appendix details the CEPSim implementation. It starts with an overview of the simulator components, and it is followed by a description of the core classes. The integration of CEPSim with the CloudSim toolkit is also discussed.

@&#OVERVIEW@&#

Based on the design principles and goals presented in Section  3, CEPSim has been designed with three main components, as shown in Fig. A.1
                        : 
                           
                              •
                              
                                 CEPSim Core: implements the CEPSim concepts from Fig. 1. It provides APIs that enable the definition of queries and the creation of operator placement and scheduling strategies. In addition, it also implements the simulation logic described in Section  5.


                                 CloudSim: implements the CloudSim concepts from Fig. 1. It provides the overall simulation framework, which controls the main simulation loop and the scheduling of simulation events. It is also used to define the cloud computing environment where the queries are simulated and to customize resource allocation policies.


                                 CEPSim Integration: implements the pieces necessary to integrate the CloudSim simulation engine with the CEP-specific logic provided by CEPSim Core. It guarantees a loose coupling between the two and enables future integration with other simulators.

The following subsections detail the CEPSim Core and Integration components.


                        CEPSim Core classes and interfaces can be grouped into four main packages: event, which contains the event set and event set queue definitions; the query model, which contains the base classes used to describe queries; the query executor, which manages the query simulation; and metrics, which contains the metrics calculation framework.

The class diagram in Fig. A.2
                         shows the main parts of the event and query model packages. Event sets and event set queues are implemented by classes with the same respective names in the 
                           e
                           v
                           e
                           n
                           t
                         package. The 
                           Q
                           u
                           e
                           r
                           y
                         class represents CEP queries and, as determined by its definition, is composed of one or more 
                           V
                           e
                           r
                           t
                           e
                           x
                         objects and one or more 
                           E
                           d
                           g
                           e
                        s.

Two subclasses of 
                           V
                           e
                           r
                           t
                           e
                           x
                         have been identified: 
                           O
                           u
                           t
                           p
                           u
                           t
                           V
                           e
                           r
                           t
                           e
                           x
                         and 
                           I
                           n
                           p
                           u
                           t
                           V
                           e
                           r
                           t
                           e
                           x
                        . The former represents vertices with outgoing edges, and the latter represents vertices with incoming edges. Note that both 
                           O
                           u
                           t
                           p
                           u
                           t
                           V
                           e
                           r
                           t
                           e
                           x
                         and 
                           I
                           n
                           p
                           u
                           t
                           V
                           e
                           r
                           t
                           e
                           x
                         have one or more instances of the 
                           E
                           v
                           e
                           n
                           t
                           S
                           e
                           t
                           Q
                           u
                           e
                           u
                           e
                         class representing their output and input queues respectively.

The 
                           E
                           v
                           e
                           n
                           t
                           P
                           r
                           o
                           d
                           u
                           c
                           e
                           r
                         class describes event producers and therefore is a subclass of 
                           O
                           u
                           t
                           p
                           u
                           t
                           V
                           e
                           r
                           t
                           e
                           x
                         only. Similarly, 
                           E
                           v
                           e
                           n
                           t
                           C
                           o
                           n
                           s
                           u
                           m
                           e
                           r
                         characterizes event consumers and is a subclass of 
                           I
                           n
                           p
                           u
                           t
                           V
                           e
                           r
                           t
                           e
                           x
                        . An 
                           O
                           p
                           e
                           r
                           a
                           t
                           o
                           r
                         is both an 
                           O
                           u
                           t
                           p
                           u
                           t
                           V
                           e
                           r
                           t
                           e
                           x
                         and an 
                           I
                           n
                           p
                           u
                           t
                           V
                           e
                           r
                           t
                           e
                           x
                         because it receives events from some vertices and sends them to others. The 
                           O
                           p
                           e
                           r
                           a
                           t
                           o
                           r
                         class also has a 
                           W
                           i
                           n
                           d
                           o
                           w
                           e
                           d
                           O
                           p
                           e
                           r
                           a
                           t
                           o
                           r
                         subclass that is used to represent windowed operators.

Finally, note that every 
                           E
                           v
                           e
                           n
                           t
                           P
                           r
                           o
                           d
                           u
                           c
                           e
                           r
                         is associated with a 
                           G
                           e
                           n
                           e
                           r
                           a
                           t
                           o
                           r
                         instance, which implements the generation function defined in Eq. (2). CEPSim currently contains two implementations of this function: 
                           
                              •
                              
                                 
                                    U
                                    n
                                    i
                                    f
                                    o
                                    r
                                    m
                                    G
                                    e
                                    n
                                    e
                                    r
                                    a
                                    t
                                    o
                                    r
                                 : generates a constant number of events per simulation interval;


                                 
                                    U
                                    n
                                    i
                                    f
                                    o
                                    r
                                    m
                                    I
                                    n
                                    c
                                    r
                                    e
                                    a
                                    s
                                    e
                                    G
                                    e
                                    n
                                    e
                                    r
                                    a
                                    t
                                    o
                                    r
                                 : generates a uniformly increasing number of events until it reaches a maximum rate. After this point, this maximum rate is maintained until the end of the simulation.

The main classes and interfaces of the query executor and metrics packages are shown in Fig. A.3
                        . The 
                           P
                           l
                           a
                           c
                           e
                           m
                           e
                           n
                           t
                         class is the central entity, representing the mapping of one or more vertices to the VM in which they will be executed. To create these placements, CEPSim users must provide an implementation of the 
                           O
                           p
                           P
                           l
                           a
                           c
                           e
                           m
                           e
                           n
                           t
                           S
                           t
                           r
                           a
                           t
                           e
                           g
                           y
                         interface, which defines an operator placement strategy. Currently, 
                           C
                           u
                           s
                           t
                           o
                           m
                           O
                           p
                           P
                           l
                           a
                           c
                           e
                           m
                           e
                           n
                           t
                           S
                           t
                           r
                           a
                           t
                           e
                           g
                           y
                         is the only strategy provided by CEPSim, but others can be easily added. In this strategy, users must manually specify the mapping of vertices to VMs.

The 
                           P
                           l
                           a
                           c
                           e
                           m
                           e
                           n
                           t
                           E
                           x
                           e
                           c
                           u
                           t
                           o
                           r
                         class encapsulates a 
                           P
                           l
                           a
                           c
                           e
                           m
                           e
                           n
                           t
                         and implements the placement simulation algorithm described in Section  5.4. This class uses an instance of the 
                           O
                           p
                           S
                           c
                           h
                           e
                           d
                           u
                           l
                           e
                           S
                           t
                           r
                           a
                           t
                           e
                           g
                           y
                         interface, which defines the operator scheduling strategy to be used during the simulation. Note that implementations for the scheduling and allocation strategies described in Section  5.1 are provided out-of-the-box by CEPSim.

In addition, the 
                           P
                           l
                           a
                           c
                           e
                           m
                           e
                           n
                           t
                           E
                           x
                           e
                           c
                           u
                           t
                           o
                           r
                         also interacts with one or more instances of the 
                           M
                           e
                           t
                           r
                           i
                           c
                           C
                           a
                           l
                           c
                           u
                           l
                           a
                           t
                           o
                           r
                         interface to calculate the simulation metrics. The 
                           L
                           a
                           t
                           e
                           n
                           c
                           y
                           T
                           h
                           r
                           o
                           u
                           g
                           h
                           p
                           u
                           t
                           C
                           a
                           l
                           c
                           u
                           l
                           a
                           t
                           o
                           r
                         class shown in the figure is a built-in implementation that computes both metrics described in Section  5.5.

In accordance with the reuse design principle, CEPSim leverages many functionalities provided by CloudSim to enable the simulation of CEP queries. This section describes how CloudSim has been extended and integrated with the CEPSim core. The main parts of this extension are depicted in the class diagram in Fig. A.4
                        .

The main part of this extension is the 
                           C
                           e
                           p
                           Q
                           u
                           e
                           r
                           y
                           C
                           l
                           o
                           u
                           d
                           l
                           e
                           t
                         class, a 
                           C
                           l
                           o
                           u
                           d
                           l
                           e
                           t
                         specialization that encapsulates the 
                           P
                           l
                           a
                           c
                           e
                           m
                           e
                           n
                           t
                           E
                           x
                           e
                           c
                           u
                           t
                           o
                           r
                         class described in the preceding section. During the simulation, a 
                           C
                           e
                           p
                           Q
                           u
                           e
                           r
                           y
                           C
                           l
                           o
                           u
                           d
                           l
                           e
                           t
                         orchestrates a 
                           P
                           l
                           a
                           c
                           e
                           m
                           e
                           n
                           t
                           E
                           x
                           e
                           c
                           u
                           t
                           o
                           r
                         execution by invoking the 
                           s
                           i
                           m
                           u
                           l
                           a
                           t
                           e
                         method at each simulation tick.

The other main classes created for the integration are: 
                           
                              •
                              
                                 
                                    C
                                    e
                                    p
                                    S
                                    i
                                    m
                                    B
                                    r
                                    o
                                    k
                                    e
                                    r
                                 : a mediator between cloud users and providers  [12]. The 
                                    C
                                    e
                                    p
                                    S
                                    i
                                    m
                                    B
                                    r
                                    o
                                    k
                                    e
                                    r
                                  extends the CloudSim broker to handle 
                                    C
                                    e
                                    p
                                    Q
                                    u
                                    e
                                    r
                                    y
                                    C
                                    l
                                    o
                                    u
                                    d
                                    l
                                    e
                                    t
                                 s. It also keeps a mapping of all vertices to the VMs to which they have been allocated.


                                 
                                    C
                                    e
                                    p
                                    S
                                    i
                                    m
                                    D
                                    a
                                    t
                                    a
                                    c
                                    e
                                    n
                                    t
                                    e
                                    r
                                 : this datacentre specialization handles 
                                    C
                                    e
                                    p
                                    Q
                                    u
                                    e
                                    r
                                    y
                                    C
                                    l
                                    o
                                    u
                                    d
                                    l
                                    e
                                    t
                                 s and guarantees that the state of all simulated entities is updated at equally spaced intervals.


                                 
                                    C
                                    e
                                    p
                                    Q
                                    u
                                    e
                                    r
                                    y
                                    C
                                    l
                                    o
                                    u
                                    d
                                    l
                                    e
                                    t
                                    S
                                    c
                                    h
                                    e
                                    d
                                    u
                                    l
                                    e
                                    r
                                 : a cloudlet scheduler defines how the processing power of a VM is shared among all cloudlets allocated to it  [12]. This research extends the time-shared policy to handle infinite or duration-based cloudlets.

The sequence diagram in Fig. A.5
                         summarizes how these classes work in tandem to implement a simulation cycle. First, the 
                           C
                           e
                           p
                           S
                           i
                           m
                           D
                           a
                           t
                           a
                           c
                           e
                           n
                           t
                           e
                           r
                         receives a 
                           V
                           m
                           _
                           D
                           a
                           t
                           a
                           c
                           e
                           n
                           t
                           e
                           r
                           _
                           E
                           v
                           e
                           n
                           t
                         signal, which is a CloudSim simulation event used to update the state of all simulated entities in a datacentre. By default, this event is signalled when cloudlets resume or end their execution. In CEPSim, this behaviour has been changed so that the event is signalled at regular intervals with the length of a simulation tick. This guarantees that the CEP queries are periodically updated and renders the simulation more precise.

After receiving this event, 
                           C
                           e
                           p
                           S
                           i
                           m
                           D
                           a
                           t
                           a
                           c
                           e
                           n
                           t
                           e
                           r
                         invokes the 
                           u
                           p
                           d
                           a
                           t
                           e
                           V
                           m
                           s
                           P
                           r
                           o
                           c
                           e
                           s
                           s
                           i
                           n
                           g
                         method in all hosts in the datacentre. Note that the current simulation time is passed as a parameter of this method call and therefore all hosts share the same clock. Then each host calls another 
                           u
                           p
                           d
                           a
                           t
                           e
                           V
                           m
                           s
                           P
                           r
                           o
                           c
                           e
                           s
                           s
                           i
                           n
                           g
                         method in all VMs currently deployed on it. At this point, the host also informs the number of MIPS allocated to each VM, which is obtained based on the VM scheduling policy in use.

Next, the VM delegates the update task to the cloudlet scheduler, which determines the number of instructions available to each cloudlet running on that particular VM based on the time-shared policy. Finally, the method 
                           u
                           p
                           d
                           a
                           t
                           e
                           C
                           l
                           o
                           u
                           d
                           l
                           e
                           t
                           F
                           i
                           n
                           i
                           s
                           h
                           e
                           d
                           S
                           o
                           F
                           a
                           r
                         is invoked on every 
                           C
                           e
                           p
                           Q
                           u
                           e
                           r
                           y
                           C
                           l
                           o
                           u
                           d
                           l
                           e
                           t
                        , which delegates the simulation to the encapsulated instance of 
                           P
                           l
                           a
                           c
                           e
                           m
                           e
                           n
                           t
                           E
                           x
                           e
                           c
                           u
                           t
                           o
                           r
                        .

Supplementary material related to this article can be found online at http://dx.doi.org/10.1016/j.future.2015.10.023.

The following is the Supplementary material related to this article. 
                        
                           MMC S1
                           
                              Difference between Storm and CEPSim estimated average latency (in ms).
                           
                           
                        
                     
                  

@&#REFERENCES@&#

