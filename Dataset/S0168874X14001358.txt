@&#MAIN-TITLE@&#3D Delaunay triangulation of non-uniform point distributions

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Regular grid insertion to achieve linear complexity in Delaunay triangulation.


                        
                        
                           
                           An enhanced kd-tree insertion scheme for non-uniformly distributed points.


                        
                        
                           
                           Multi-grid insertion scheme as a recursive application of regular grid insertion.


                        
                        
                           
                           Benchmark non-uniform point distributions from 0.4 million to 20 million points.


                        
                        
                           
                           The multi-grid insertion scheme is robust and the most efficient.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

3D Delaunay triangulation

Non-uniform point distributions

Regular grid

Multi-grid




                     kd-Tree insertions

@&#ABSTRACT@&#


               
               
                  In view of the simplicity and the linearity of regular grid insertion, a multi-grid insertion scheme is proposed for the three-dimensional Delaunay triangulation of non-uniform point distributions by recursive application of the regular grid insertion to an arbitrary subset of the original point set. The fundamentals and difficulties of three-dimensional Delaunay triangulation of highly non-uniformly distributed points by the insertion method are reviewed. Current strategies and methods of point insertions for non-uniformly distributed spatial points are discussed. An enhanced kd-tree insertion algorithm with a specified number of points in a cell and its natural sequence derived from a sandwich insertion scheme is also presented.
                  The regular grid insertion, the enhanced kd-tree insertion and the multi-grid insertion have been rigorously studied with benchmark non-uniform distributions of 0.4–20 million points. It is found that the kd-tree insertion is more efficient in locating the base tetrahedron, but it is also more sensitive to the triangulation of non-uniform point distributions with a large amount of conflicting elongated tetrahedra. Including the grid construction time, multi-grid insertion is the most stable and efficient for all the uniform and non-uniform point distributions tested.
               
            

@&#INTRODUCTION@&#

Based on a simple geometrical concept, Delaunay triangulation has important applications in many fields, including data visualization, terrain modelling, finite element mesh generation, surface reconstruction, bio-medical modelling from images and structural networking for arbitrary point sets, etc. [1,2]. The popularity of Delaunay triangulation is attributed to its sound geometric properties as a dual of Voronoi tessellation and the speed with which it can be constructed in two and higher dimensions. In view of its diverse applications, many strategies for its construction have been proposed. In a paper by Su and Drydale [3], numerical tests of uniformly and non-uniformly distributed point sets on several Delaunay triangulation algorithms, namely, divide-and conquer, sweep line algorithms, incremental algorithms, a fast incremental construction algorithm, gift wrapping algorithms and convex hull based algorithms were carried out and their performance were compared.

With a rapid increase in the problem size from thousands of points to millions of points, it is necessary to devise ever more efficient schemes for the construct of Delaunay triangulations. Uniform or mildly non-uniform distribution point sets can be efficiently handled by the insertion scheme with the aid of a regular grid [4,5]. However, for highly non-uniform point distributions, the triangulation time may be many times more than that is required by a uniform point distribution. For the Delaunay triangulation of severe non-uniform point distributions, the complexity is nonlinear, such that the triangulation time may be excessively long for large point sets of millions of points.

Relative to a uniform point distribution, non-uniform point sets are significantly more difficult due to the following intrinsic properties of non-uniformly distributed points: (i) more efficient space control or partition has to be applied to highly non-uniform distributed points so that each partitioned cell contains roughly equal number of points. (ii) In the location of the base tetrahedron by the point insertion algorithm, the CPU time taken or the number of tetrahedra examined before the base tetrahedron could be determined is much longer than the case of uniform distribution as there are many pointed tetrahedra in the triangulation. (iii) In the creation of the insertion cavity upon the introduction of a new point, many tetrahedra have to be removed and reconstructed as long thin tetrahedra have large circumspheres, and a point can be connected to many distant points through long stretching tetrahedra. (iv) There are problems of numerical stability both in the determination of the base tetrahedron and in the verification of the empty circumsphere criterion, and more CPU time has to be allowed to exercise additional consistency checks and precautions.

In this paper, the difficulties of Delaunay triangulation of non-uniform point distributions by the insertion algorithm are discussed, and versatile enhanced kd-tree and multi-grid insertion schemes are proposed and tested with large sets of highly non-uniformly distributed points.

The Delaunay triangulation of a set of points on a plane is defined to be a triangulation such that the circumcircle of every triangle in the triangulation contains no point from the set in its interior. Such a triangulation exists for a given set of points, and it is the dual of the Voronoi tessellation. The triangulation is unique if the points are in general positions, i.e. no four points are cyclic. A triangle T is said to be Delaunay with respect to a point p if p does not lie inside the circumcircle of T. A triangle T in a triangulation of a set of points is called Delaunay triangle if T is Delaunay with respect to every point in the set. A triangulation of a set of points is called the Delaunay triangulation of the point set if every triangle in the triangulation is a Delaunay triangle as shown in 
                        Fig. 1. The idea of Delaunay triangulation is very general, which can be easily extended to higher dimensions. For instance, the Delaunay triangulation in three dimensions is given by replacing triangle by tetrahedron, circle by sphere and 2D plane by 3D space. The following lemma provides the basis for many algorithms in the construction and verification of Delaunay triangulation.


                        Lemma of Delaunay 
                        [6]. Let T
                        (
                           S
                        ) be a triangulation of the point set S. The necessary and sufficient condition that no point of S is contained in the circumcircle of any triangle in the triangulation is that any two adjacent triangles in the triangulation are Delaunay with respect to each other’s vertices.
                     

For the construction of Delaunay triangulation in three and higher dimensions, point insertion algorithm is the most popular, and many interesting methods have been proposed [2]. For a set of 3D points, the initial triangulation is a rectangular box consisting of five or six Delaunay tetrahedra large enough to contain all the given points as shown in 
                        Fig. 2. The Delaunay triangulation is achieved by inserting points one by one into the initial triangulation. Each cycle of point insertion can be divided into three steps.
                           
                              (i)
                              For a newly inserted point, identify all the tetrahedra whose circumsphere contains the point in its interior. The CORE which is the cavity left behind upon removal of these tetrahedra forms a star-shaped insertion polyhedron.

Owing to the finite precision arithmetic, the triangulation facets on the boundary of the CORE have to be verified with the visibility check and corrected before they are connected with the inserted point to form tetrahedra.

The triangulation of the insertion polyhedron should be trivial. However, the adjacency relationship of the tetrahedra has to be established, which will be frequently referred to throughout the triangulation process.

The visibility test is a simple test to make sure that each triangular facet on the boundary of the CORE is visible to the insertion point P 
                        [2]. Once the boundary of the CORE is established by the sphere inclusion test, the CORE consists of all the non-Delaunay tetrahedra with respect to the insertion point P. One of the major difficulties in the implementation of the Delaunay triangulation by point insertion is to ensure consistency in the sphere inclusion test based on finite precision computations. An inconsistent decision in the sphere inclusion test may result in a disconnected CORE. Imprecise numerical calculation may also introduce tetrahedral with zero or negative volumes. Another type of degeneracy in three dimensions, which is due to the nature of Delaunay triangulation rather than the result of numerical error, can occur when four points are coplanar and cyclic. It is possible for these four points to form a tetrahedron of zero volume with non-zero edges and faces, which is known as sliver.

Using higher precision arithmetic can only postpone the problem to solve more cases which are near to degeneracy, but not to solve it completely. In 1992, Baker [25] proposed a solution in which tolerances depending on the values of the data and the machine precision are applied to all real number calculations. A more elegant solution is to use adaptive precision floating point arithmetic [26,27], which in theory would not introduce any numerical error for a wrong decision in case of nearly co-spherical points (i.e. five or more points on the circumsphere of a tetrahedron). However, exact integer arithmetic is not the panacea to all the problems, and the situation of exactly co-spherical points and natural degeneracy of sliver in Delaunay triangulation are still not resolved with robust geometric predicates [28]. Hardware and compilers may also prevent the algorithm from functioning properly, and even though a right decision is arrived for the sphere inclusion test, the connection is not unique and we do not have a systematic way in joining up any number of points on the surface of a sphere to produce a consistent triangulation, and sliver elements of zero or nearly zero volume will still be formed. Nevertheless, the visibility or the positive volume test appears to be simple and reliable in ensuring the CORE is connected and the volume of every tetrahedron is positive for a wide range of point distributions.

When a new point p is inserted in a Delaunay triangulation, it is required to find all the tetrahedra whose circumsphere contains the point p. A simple method to determine those non-Delaunay tetrahedra is to scan through all the existing tetrahedra for those circumspheres containing the point p. However, a more efficient approach is to start with the tetrahedron which contains the inserted point p and find the others by means of the adjacency relationship. In this way, the boundary of the insertion polyhedron is given by the common faces of two tetrahedra for which one is positive in the sphere inclusion test while the other fails. The tetrahedron which contains the insertion point p is called the base, which is a core part of the insertion polyhedron.

Although the end result of Delaunay triangulation of a set of n distinct points is independent of the order following which the points are inserted, the time taken or the complexity of triangulation is very sensitive to the sequence how points are processed. For the triangulation of randomly generated points by insertion, the complexity can vary from O(n) to O(n
                        2) depending on the order of point insertion. For the 3D triangulation of 1 million points on a PC, if points are inserted following the natural order of point generation, triangulation time increased rapidly in a nonlinear manner with the number of points inserted as shown in 
                        Fig. 3. On the other hand, also shown in Fig. 3, if points are sorted and inserted more or less in a contiguous manner, a linear time relationship of the same set of points is resulted. For a 3D triangulation of 1 million points, it took 48s for unsorted points but only 8s for sorted points, and this quasi-linear complexity can be sustained up to 50 million 3D points in 456s.

Realizing that the point insertion sequence has a great impact on the time in locating the base tetrahedron, many schemes has been devised in determining how points should be ordered so as to reduce the time of triangulation [7–12]. This observation is in line with the second interesting remark under Notes and Discussion of the paper by Su and Drysdale [3], “A simple enhancement of the naïve incremental algorithm results in an easy to implement algorithm that runs in O(n) expected time for uniformly distributed sites. It is faster than previous incremental variants and competitive with other known algorithms for constructing the Delaunay triangulation for all but very bad sites”.

In the point insertion algorithm, there are two basic steps, namely, (i) the location of the base triangle containing the inserted point and (ii) to ensure the circumcircle criterion is verified for all the triangles connected to the inserted point. If points are inserted by means of adjacent cells as shown in 
                        Fig. 4, the searching path in determining the base is a constant depending on the number of points in a cell, and the verification of the circumcircle criterion is a local process if we follow the adjacency relationship of the triangles, thanks to lemma of Delaunay. From this observation, it can be seen that Delaunay triangulation by point insertion is one of the most efficient algorithms for its simplicity and linearity provided that points are inserted in clusters in a contiguous manner like the growth of crystals.

Point insertion following an ordered cell sequence for Delaunay triangulation of points in clusters is a very simple and efficient scheme as the number of operations is almost optimal. Consider 3D point insertion, it takes n scans of tetrahedra on average in locating the base tetrahedron, where n is the number of points in a cell, and on average a point is connected to 27 tetrahedra for which circumsphere criterion has to be verified. A simple count illustrates that on average the number of operations for each point insertion is n+27=35 if each cell contains roughly 8 points. Numerical tests on the insertion of 1 million randomly generated points by PC shows that 1 million Delaunay tetrahedra can be constructed per second by a sequential insertion process, which is the fastest rate ever published known to the author.

As for non-uniform point distributions, spatial partition of 3D points can be achieved by the Octree [13] or kd-tree [14]. Nevertheless, the time complexity for the construction of Octree or kd-trees is of order O(n
                        log
                        n) for a set of n points, which indicates that the time complexity of Delaunay triangulation by point insertion in the worst case is at least O(n
                        log
                        n) unless the barrier of spatial point partition could be overcome by some more intelligent schemes of lower order.

As for the identification of the insertion cavity, the number of tetrahedra checked and removed depends on the insertion sequence as well as the intrinsic characteristics and pattern of the point distributions. No theoretical results have been reported so far as how to devise an optimized order so as to minimize the number of conflicting tetrahedra in the entire triangulation process. While this is not an issue in uniform point distribution, for non-uniform point distributions, the total number of tetrahedra removed varies significantly with the order of point insertion. For highly non-uniform point distributions, over many parts, long thin tetrahedra with large circumscribing spheres exist. Upon the introduction of a newly inserted point near a cluster of elongated tetrahedra, a large number of tetrahedra have to be removed and reconstructed as shown in 
                        Fig. 5. If points are to be inserted in a contiguous manner close to each other, the removal and reconstruction of elongated tetrahedra have to be repeated for each point insertion. Obviously, this is a rather time-consuming and perhaps unnecessary. The dilemma is that in order to reduce the time in searching for the base tetrahedron, points have to be inserted in a contiguous manner; however, in order not to remove and reconstruct elongated triangles in an excessive manner, points have to be inserted with sufficient separation. An effective algorithm ought to optimize both the search for the base and the conflicting tetrahedra in the creation of the insertion polyhedron (cavity).

In the earlier algorithms, points were introduced by the natural order (the order as their input) or sorted by a lexical axis-order [15]. This scheme has a tendency to produce intermediate triangulations of higher complexity than the final triangulation. The widely used random order was then devised to overcome the shortcomings of natural or lexical axis-order; it simply states that shuffle the points and insert them one by one [16]. There are several robust and efficient implementations of the incremental Delaunay triangulation construction based on random order point insertion, such as Clarkson’s Hull [17] and that contained in the α-shapes software of Edelsbruner et al. [18].

Amenta N. et al. presented a biased randomized insertion order (BRIO) in 2003 [16]. Their argument was that since modern memory architecture is hierarchical and the paging policies favour programs that observe locality of reference, a major concern is cache coherence: a sequence of recent memory references should be clustered locally rather than randomly in the address space. A programme implementing a randomized algorithm does not observe this rule and can be dramatically slowed down when its address space no longer fits in the main memory. The Biased Randomized Insertion Order (BRIO) preserves enough randomness in the input points so that the performance of a randomized incremental algorithm is unchanged but orders the points by spatial locality to improve cache coherence. However, from the reports of other researchers [8,9], the practical performance of BRIO is not promising. Indeed, Amenta et al. considered BRIO a concept depending on the ever changing memory allocation schemes rather than a specific order, and BRIO could be implemented by merging with various insertion orders in a variety of ways.

Recently, the pendulum seems to have swung back to the deterministic order. Due to the work of Liu and Snoeyink [8], Sheng Zhou and Jones [9], Boissonnat et al. [10], Buchin [11,12], the space-filling curve orders are widely used for constructing Delaunay triangulations. Among them, the Hilbert curve order is considered to be the most efficient order because of its locality-preserving behaviour. In 2005, Liu and Snoeyink used the Hilbert curve order in their programme tess3 for 3D Delaunay tessellation and compared it with qhull, CGAL2.4, pyramid and hull [8]. In their empirical comparisons, tess3 was the fastest for both uniform and non-uniform point distributions. Now the Hilbert curve order is also employed in the latest version of CGAL—CGAL3.7 [19], though mixing with the idea of BRIO in its implementation.

As a variant of the space-filling curve developed by Giuseppe Peano [20], the Hilbert curve is a fractal continuous space-filling curve first described by David Hilbert in 1891 [21]. Its construction rule in the 2D case is shown in 
                        Fig. 6. A square with an arrow is subdivided into four sub-squares. The ordering of the sub-squares is indicated by a blue arrow which connects the centres of neighbouring sub-squares. By repeat subdivision of each sub-square, the curve produced by linking up all the arrows becomes longer and longer; and it is called a Hilbert curve. The division into smaller squares or cells is applied uniformly over the entire domain to produce sub-squares of equal size, which can be controlled by specifying the maximum number of points in a sub-square. The Hilbert curve is designed to provide a path passing through all the sub-squares, so that points will be inserted cell by cell in a reasonably contiguous manner. However, extra time has to be allowed in the cell subdivision and management, and in formulating the insertion path which may go through many empty cells.

In triangulation, a background grid is a partition of space to facilitate searching or to establish a neighbourhood relationship for various quantities. Depending on the distribution of the points or objects under consideration and other specific requirements, grids of different characteristics have been constructed. By the use of a background grid, the space will be partitioned into cells, and the ideal scenario is to divide the space such that each cell will hold roughly equal number of points. According to different point distributions, regular grids of equal and unequal spacings, Quad/Oct-tree and kd-tree partitions, etc. have been devised.

Regular grids with equal and unequal spacing are the simplest and easy to create with linear complexity, hence their construction is almost without any cost. Nevertheless, they are very effective in dealing with objects with normal or random distributions, and they are also very useful as a space control even for mildly non-uniform distributions. The basic properties, the procedure of construction, general characteristics and memory requirement of a regular grid will be elaborated in Section 4. Point insertion by means of a regular grid for uniform and non-uniform point distributions will be fully investigated in Section 5.


                        kd-tree construction is an effective space control for highly non-uniformly distributed data. Points are partitioned into two equal portions (differ at most by one point) by taking the median of the point set. This procedure is repeated as necessary until there is no more than one point in each subdivided region. By the very construction of the kd-tree taking the median to divide a point set, at an intermediate stage, the number of points in a region (cell) is always equal no matter how points are distributed. The price to pay is to determine the median of the points in a cell for each subdivision by means of a sorting process, or more effectively by means of the Bin Sort or the Address Sort. The points in the cells along with the sequence of pivots of subdivision points form a sorted insertion order for the original point set. In a paper “A New Insertion Sequence for Incremental Delaunay Triangulation” by Liu et al. [22], it is reported that kd-tree insertion is superior to Random, BRIO and Hilbert curve insertions up to 3 million 3D non-uniformly distributed points in various patterns such as cluster, disc, curved surface, line, spiral, etc.

In view of the better performance of kd-tree insertion over Random, BRIO and Hilbert curve insertions for a wide range of non-uniform point distributions, Random, BRIO and Hilbert curve will not be further explored in this paper. On the other hand, the regular grid insertion, the kd-tree insertion and its enhanced version developed in Section 3 will be rigorously tested against a wide range of data points from 0.4 to 20 million over a variety of non-uniform distribution patterns. In the light of the ease of construction of the regular grid and its linear characteristic for uniform distributed data, a new insertion scheme is proposed by recursive application of regular grid insertion to non-uniform distributed points partitioned into cells by regular grid or kd-tree. Exploiting the local homogeneity of non-uniformly distributed points, regular grid insertion is especially effective over uniform or non-uniform point distributions partitioned into tiny cells of a large number of points. The procedure of multi-grid insertion will be developed in Section 4, and the idea will be fully tested also in Section 5.

Based on the idea of space partition, a k-d tree (short form for k-dimensional tree) is a data structure in the form of a branching tree for organizing points in k-dimensional space. k-d trees provide a hierarchic spatial relationship between data points, which can be used to find nearest neighbours, locate points within a zone, and for other searching operations, such as construction and point insertion of Delaunay triangulation [23,24].

A 2-d tree is generated by selecting a pivot point Q
                           1 from the given point set to separate the remaining points into two regions by passing a vertical line through the chosen point. Points with x-values smaller than that of Q
                           1 will be put to the region on the left, whereas points with x-values greater than that of Q
                           1 will be put to the region on the right as shown in 
                           Fig. 7, and points with equal x-values can be put on either side. In the second step, Q
                           2 and Q
                           3 are selected respectively from the regions to further divide them each into two sub-regions along the y-direction. This time, the regions are divided into smaller regions by horizontal lines passing points Q
                           2 and Q
                           3, so that roughly equal number of points are above and below the horizontal lines. Obviously, this subdivision process can be repeated by selecting one point from each region as pivot to create more sub-regions. As one point, the pivot, is taken away for each subdivision, for a set of N points there are N divisions and the space will be partitioned into N+1 regions.

A balanced tree will be resulted if the median is always selected as the pivot for each region sub-division, and in this case each region will contain approximately equal number of points (differ at most by one point). For a balanced tree construction, the level of subdivision can be calculated as the number of points in a region is reduced by half in each subdivision, and all the leaf nodes (nodes at the bottom of the tree) are about the same distance from the root. To construct a balanced k-d tree for a set of N points, the level of subdivision, L, is given by
                              
                                 
                                    
                                       
                                          2
                                       
                                       L
                                    
                                    ≥
                                    N
                                    ⇒
                                    L
                                    ≥
                                    
                                       
                                          log
                                       
                                       
                                          2
                                       
                                    
                                    (
                                    N
                                    )
                                    ⇒
                                    L
                                    =
                                    [
                                    
                                       
                                          log
                                       
                                       
                                          2
                                       
                                    
                                    (
                                    N
                                    )
                                    ]
                                    +
                                    1
                                    .
                                 
                              
                           where [ ]=Integral part

Hence,
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                             L=1,
                                          
                                             N=1.
                                       
                                       
                                          
                                             L=2,
                                          
                                             N=2, 3.
                                       
                                       
                                          
                                             L=3,
                                          
                                             N=4, 5, 6, 7.
                                       
                                       
                                          
                                             L=4,
                                          
                                             N=8, 9, 10, 11, 12, 13, 14, 15, and so on.
                                       
                                    
                                 
                              
                           
                        

For a more symmetrical partition of space, the line of subdivision, vertical or horizontal, is rotated for each change of level of subdivision, i.e. L=1, vertical, L=2, horizontal, L=3, vertical, and so forth.

A k-d tree can be conveniently defined by a proper sequencing of the given set of N points, P={P
                           
                              i
                           , i=1, N}. The following describes how a region P
                           
                              i
                            is divided into two sub-regions P
                           
                              k
                            and P
                           
                              k+1. Find the median from P
                           
                              i
                            as pivot along the x-axis or y-axis depending on the level of subdivision. Set Q
                           
                              i
                           =median, which divides P
                           
                              i
                            into P
                           
                              k
                            containing points on the left of P
                           
                              i
                            and P
                           
                              k+1 containing points on the right of P
                           
                              i
                           . As Q
                           
                              i
                            is the median in P
                           
                              i
                           , the number of points in P
                           
                              k
                            and the number of points in P
                           
                              k+1 are given by
                              
                                 
                                    
                                       
                                          N
                                       
                                       
                                          k
                                       
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  N
                                                               
                                                               
                                                                  i
                                                               
                                                            
                                                            −
                                                            1
                                                         
                                                         2
                                                      
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      
                                                         
                                                            N
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      
                                                      is
                                                      
                                                      odd
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  N
                                                               
                                                               
                                                                  i
                                                               
                                                            
                                                         
                                                         2
                                                      
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      
                                                         
                                                            N
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      
                                                      is
                                                      
                                                      even
                                                      ,
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                    
                                       
                                          N
                                       
                                       
                                          k
                                          +
                                          1
                                       
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  N
                                                               
                                                               
                                                                  i
                                                               
                                                            
                                                            −
                                                            1
                                                         
                                                         2
                                                      
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      
                                                         
                                                            N
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      
                                                      is
                                                      
                                                      odd
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  N
                                                               
                                                               
                                                                  i
                                                               
                                                            
                                                         
                                                         2
                                                      
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      
                                                         
                                                            N
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      
                                                      is
                                                      
                                                      even
                                                      .
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where N
                           
                              i
                            is the number of points in P
                           
                              i
                           . The subdivision will be carried out following the order of construction of the regions. As one point, Q
                           
                              i
                           , is taken away for the subdivision of region P
                           
                              i
                           , the sequence {Q
                           
                              i
                           , i=1, N} will be established after exactly N subdivisions.

Set P
                           1=P={P
                              i
                           , i=1, N
                           1}, where N
                           1=N. P
                           1 will give rise to P
                           2 and P
                           3, and P
                           2 will generate P
                           4 and P
                           5, whereas P
                           3 will generate P
                           6 and P
                           7. In turn, P
                           4 will generate P
                           8 and P
                           9, and P
                           5 will generate P
                           10 and P
                           11, and so on, as shown in 
                           Fig. 8.

Let us consider the relationship of the points in the sequence {Q
                           
                              k
                           , k=1, N} associated with region subdivisions, P
                           1, P
                           2,…, P
                           
                              N
                           . Q
                           1 is the root node, which has child nodes Q
                           2 and Q
                           3 and in general, Q
                           
                              k
                            generates Q
                           2k
                            and Q
                           2k+1. Hence, Q
                           2k
                            and Q
                           2k+1 are children of Q
                           
                              k
                           , and Q
                           
                              k
                            is the father of Q
                           2k
                            and Q
                           2k+1 as shown in Figs. 7 and 8. Hence, Q
                           
                              k/2 is the father node of Q
                           
                              k
                           , and in case k/2=0 or k=1, Q
                           
                              k
                            is already at the top of the tree. Generalizing the previous results, the grand-father (2 levels up) of Q
                           
                              k
                            is given by Q
                           
                              k/4, and so on.

The concept and the procedure for the construction of 2-d tree can be generalized naturally to higher dimensions. In three dimensions, k=3, the space/regions are partitioned by a plane perpendicular to x-axis, y-axis or z-axis in turn according to the level of subdivision. If Q
                           
                              k
                            is on the x-aligned plane, child nodes Q
                           2k
                            and Q
                           2k+1 are on the y-aligned plane, and grand-child nodes Q
                           4k
                           , Q
                           4k+1, Q
                           4k+2 and Q
                           4k+3 are on the z-aligned plane, and so forth. The construction of a static k-d tree of n points takes O(n
                           log2(n)) time if an O(n
                           log(n)) sort is employed to compute the median for each region subdivision. The complexity becomes O(n
                           log(n)) if a linear median finding algorithm is used [15]. In the partition of regions, if the regions are cut along their longest side instead of rotating through the axes, the pattern and the performance of the k-d tree are quite different. The behaviour of the k-d trees are much better as points are more closely grouped together, and they are called squarish k-d trees [23]. It is noted that the construction of 2d-tree and 3d-tree takes roughly equal amount of CPU time, as the procedure is similar and the number of operations involved is exactly the same. A squarish 3d-tree of 1000 points distributed along a straight line is shown in 
                           Fig. 9, in which small cells are found near the diagonal.

A nice feature of kd-tree partition is that at any level of subdivision each region contains roughly equal number of points irrespective of the point distribution. In triangulation, it is not necessary to subdivide each region down to the lowest level, such that each region contains no point or only one point. A more general approach for point insertion by kd-tree partition is to allow each region to contain a specified number of points. Let N be the number of points in the set and n be the desirable number of points in a cell, the level of subdivision is given by
                           
                              
                                 
                                    
                                       2
                                    
                                    L
                                 
                                 n
                                 =
                                 N
                                 ⇒
                                 L
                                 =
                                 
                                 ln
                                 
                                    (
                                    
                                       
                                          N
                                          n
                                       
                                    
                                    )
                                 
                                 /
                                 
                                 ln
                                 (
                                 2
                                 )
                                 .
                              
                           
                        
                     

The number of cells in the partition is given by
                           
                              
                                 
                                    
                                       N
                                    
                                    
                                       c
                                    
                                 
                                 =
                                 
                                    
                                       2
                                    
                                    L
                                 
                              
                           
                        
                     

Cells are labelled in a sequential order, and for a level L subdivision, cells are labelled as
                           
                              
                                 {
                                 
                                    
                                       2
                                    
                                    L
                                 
                                 ,
                                 
                                    
                                       2
                                    
                                    L
                                 
                                 +
                                 1
                                 ,
                                 …
                                 ,
                                 
                                    
                                       2
                                    
                                    
                                       L
                                       +
                                       1
                                    
                                 
                                 −
                                 1
                                 }
                                 .
                              
                           
                        
                     

A 2d-tree is taken to illustrate the sequence of point insertion cell by cell, and the entire set of points will be inserted when all the cells and pivot points are processed. Unlike the regular grid scheme, there is no natural contiguous sequence for cells generated by a squarish kd-tree partition. However, the region splitting pivot points can serve as a link between two regions at a given level of subdivision. As shown in 
                        Fig. 10b, for partition level L=2, the insertion sequence for the cells and pivot points is given by
                           
                              
                                 {
                                 cell
                                 
                                 4
                                 –
                                 pivot
                                 
                                 2
                                 –
                                 cell
                                 
                                 5
                                 –
                                 pivot
                                 
                                 1
                                 –
                                 cell
                                 
                                 6
                                 –
                                 pivot
                                 
                                 3
                                 –
                                 cell
                                 
                                 7
                                 }
                              
                           
                        In general, for a set of points partitioned into 2
                           L
                         cells the insertion sequence is also given by a cell–pivot–cell sandwiched scheme. The cells for a level L partition are given by
                           
                              
                                 {
                                 
                                    
                                       2
                                    
                                    L
                                 
                                 ,
                                 
                                 
                                    
                                       2
                                    
                                    L
                                 
                                 +
                                 1
                                 ,
                                 
                                 …
                                 ,
                                 
                                 
                                    
                                       2
                                    
                                    
                                       L
                                       +
                                       1
                                    
                                 
                                 −
                                 1
                                 }
                              
                           
                        and the pivot points are given by {1, 2, …, 2
                           L
                        –1}

In the cell–pivot–cell sandwiched scheme, cells of points are inserted sequentially starting with cell 2
                           L
                        , and the pivot point k following cell j is given by

If j is divisible by 2, k=j/2, otherwise set j
                        1=j/2, and repeat the division process until j
                        
                           m
                         is divisible by 2, then pivot k=j
                        
                           m
                        /2. By the kd-tree construction, such a pivot point exists and is unique for all the cells between 2
                           L
                         and 2
                           L+1–2.

For example, a set of 20 points is divided into two regions(cells), in which the cell on the left contains 10 points and the cell on the right contains 9 points as shown in Fig. 10a. L=1, regions={21, 22–1}={2, 3} and pivot={1}. For L=2, the point set is partitioned into four regions as shown in Fig. 10b, in which regions={22,…, 23–1}={4, 5, 6, 7} and pivots={1, 2, 3}.

Take for instance the level L=2 partition of 20 points, the cells are {4, 5, 6, 7} and pivots={1, 2, 3}. The insertion sequence is given by
                           
                              (i)
                              Five points in cell 4 are inserted; and 4 is divided by 2, hence pivot=4/2=2.

Pivot 2 is inserted.

Four points in cell 5 are inserted; and 5 is not divisible by 2, 5/2=2 and 2 is divisible by 2, hence pivot=2/2=1.

Pivot 1 is inserted.

Four points in cell 6 are inserted; and 6 is divisible by 2, hence pivot=6/2=3.

Pivot 3 is inserted.

Four points in cell 7 are inserted.

All the 20 points in the set have been processed.

By means of the simple cell–pivot–cell sandwiched scheme, points partitioned into kd-tree cells can be inserted in a reasonable contiguous manner without much computation.

As the number of points in a cell of kd-tree is roughly equal (differ at most by one), within a kd-tree cell more sophisticated insertion scheme, say the regular grid insertion, can be applied to enhance the overall efficiency as shown in 
                        Fig. 11. For a classical kd-tree partition, the space is partitioned until there is no more points left in each cell. There are two disadvantages in doing a full kd-tree partition: (i) more CPU time is required for the partition down to the last point and (ii) points are overly sorted in a full kd-tree partition so that on average more non-Delaunay tetrahedra have to be removed in the insertion process. In the numerical tests of insertion of 0.4–20 million 3D points for various non-uniform distribution patterns, the most efficient scheme is to have about 10 points in each cell. However, if regular grid insertion is available, a more efficient insertion scheme can be devised by putting more than 1000 points in a cell. Whichever the case, the number of points in a cell is not very sensitive to the overall performance as long as it is within the right order, as it is only a statistical average depending also on the characteristics of point distributions.

A multi-grid insertion is the result of applying the regular grid insertion to each cell of a spatial partition in a recursive manner. The idea is based on the observation that the regular grid insertion scheme is very effective for uniform point distributions with a linear complexity for very large point sets. Applying regular grid partition to non-uniform point distributions, points are not evenly distributed into cells, such that there are many points in some cells and none in other cells. However, within each cell, the points are more or less evenly distributed, and regular grid insertion can be applied recursively to each cell resulting in a very simple efficient scheme with almost linear complexity for locally evenly distributed points, such as line, ellipse and cluster distributions. Absolute linear complexity for the non-uniform point distributions with more complicated patterns or topology, like the spiral and the diagonal distributions, might be more difficult as points are connected to a large number of distant points through narrow elongated tetrahedra. A quasi-linear insertion scheme is only possible unless the number of tetrahedra removed for each point insertion can be controlled in such a way that it does not increase with the number of points in the set.

A 3D uniform grid for a set of N points {P
                           
                              i
                           
                           =(x
                           
                              i
                           , y
                           
                              i
                           , z
                           
                              i
                           ), i=1,N} can be constructed following the same procedure of the 2D uniform grid. As shown in Fig. 11a, a regular grid of N
                           
                              x
                           ×N
                           
                              y
                           ×N
                           
                              z
                            cells (boxes, zones, bins) subdivides uniformly the space of interest into a number of regions such that for any given point, the cell containing it can be rapidly determined without much calculation.
                              
                                 
                                    Compute
                                    
                                    α
                                    =
                                    
                                       
                                          
                                             N
                                             
                                                n
                                                
                                                   
                                                      R
                                                   
                                                   
                                                      x
                                                   
                                                
                                                
                                                   
                                                      R
                                                   
                                                   
                                                      y
                                                   
                                                
                                                
                                                   
                                                      R
                                                   
                                                   
                                                      z
                                                   
                                                
                                             
                                          
                                       
                                       3
                                    
                                 
                              
                           where n is the average number of points in a cell,
                              
                                 
                                    
                                       
                                          R
                                       
                                       
                                          x
                                       
                                    
                                    =
                                    
                                       
                                          x
                                       
                                       
                                          max
                                       
                                    
                                    –
                                    
                                       
                                          x
                                       
                                       
                                          min
                                       
                                    
                                    ,
                                    
                                       
                                          R
                                       
                                       
                                          y
                                       
                                    
                                    =
                                    
                                       
                                          y
                                       
                                       
                                          max
                                       
                                    
                                    –
                                    
                                       
                                          y
                                       
                                       
                                          min
                                       
                                    
                                    ,
                                    
                                       
                                          R
                                       
                                       
                                          z
                                       
                                    
                                    =
                                    
                                       
                                          z
                                       
                                       
                                          max
                                       
                                    
                                    –
                                    
                                       
                                          z
                                       
                                       
                                          min
                                       
                                    
                                    .
                                 
                              
                           
                        

The number of division along each direction is given by
                              
                                 
                                    
                                       
                                          N
                                       
                                       
                                          x
                                       
                                    
                                    =
                                    N
                                    I
                                    N
                                    T
                                    (
                                    α
                                    
                                       
                                          R
                                       
                                       
                                          x
                                       
                                    
                                    )
                                    ,
                                    
                                    
                                       
                                          N
                                       
                                       
                                          y
                                       
                                    
                                    =
                                    N
                                    I
                                    N
                                    T
                                    (
                                    α
                                    
                                       
                                          R
                                       
                                       
                                          y
                                       
                                    
                                    )
                                    ,
                                    
                                    
                                       
                                          N
                                       
                                       
                                          z
                                       
                                    
                                    =
                                    N
                                    I
                                    N
                                    T
                                    (
                                    α
                                    
                                       
                                          R
                                       
                                       
                                          z
                                       
                                    
                                    )
                                    ,
                                    number
                                    
                                    of
                                    
                                    cells
                                    ,
                                    
                                       
                                          N
                                       
                                       
                                          c
                                       
                                    
                                    =
                                    
                                       
                                          N
                                       
                                       
                                          x
                                       
                                    
                                    
                                       
                                          N
                                       
                                       
                                          y
                                       
                                    
                                    
                                       
                                          N
                                       
                                       
                                          z
                                       
                                    
                                    .
                                 
                              
                           
                        

Compute the size of a cell along each direction
                              
                                 
                                    
                                       
                                          d
                                       
                                       
                                          x
                                       
                                    
                                    =
                                    
                                       
                                          R
                                       
                                       
                                          x
                                       
                                    
                                    /
                                    
                                       
                                          N
                                       
                                       
                                          x
                                       
                                    
                                    ,
                                    
                                    
                                       
                                          d
                                       
                                       
                                          y
                                       
                                    
                                    =
                                    
                                       
                                          R
                                       
                                       
                                          y
                                       
                                    
                                    /
                                    
                                       
                                          N
                                       
                                       
                                          y
                                       
                                    
                                    ,
                                    
                                    
                                       
                                          d
                                       
                                       
                                          z
                                       
                                    
                                    =
                                    
                                       
                                          R
                                       
                                       
                                          z
                                       
                                    
                                    /
                                    
                                       
                                          N
                                       
                                       
                                          z
                                       
                                    
                                    .
                                 
                              
                           
                        

Determine cell k to which point P
                           
                              i
                           =(x
                           
                              i
                           , y
                           
                              i
                           , z
                           
                              i
                           ) belongs
                              
                                 
                                    
                                       
                                          I
                                       
                                       
                                          x
                                       
                                    
                                    =
                                    [
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          i
                                       
                                    
                                    –
                                    
                                       
                                          x
                                       
                                       
                                          min
                                       
                                    
                                    )
                                    /
                                    
                                       
                                          d
                                       
                                       
                                          x
                                       
                                    
                                    ]
                                    +
                                    1
                                    ,
                                    
                                       
                                          I
                                       
                                       
                                          y
                                       
                                    
                                    =
                                    [
                                    (
                                    
                                       
                                          y
                                       
                                       
                                          i
                                       
                                    
                                    –
                                    
                                       
                                          y
                                       
                                       
                                          min
                                       
                                    
                                    )
                                    /
                                    
                                       
                                          d
                                       
                                       
                                          y
                                       
                                    
                                    ]
                                    +
                                    1
                                    ,
                                    
                                       
                                          I
                                       
                                       
                                          z
                                       
                                    
                                    =
                                    [
                                    (
                                    
                                       
                                          z
                                       
                                       
                                          i
                                       
                                    
                                    –
                                    
                                       
                                          z
                                       
                                       
                                          min
                                       
                                    
                                    )
                                    /
                                    
                                       
                                          d
                                       
                                       
                                          z
                                       
                                    
                                    ]
                                    +
                                    1
                                    ,
                                    k
                                    =
                                    (
                                    
                                       
                                          I
                                       
                                       
                                          z
                                       
                                    
                                    –
                                    1
                                    )
                                    
                                       
                                          N
                                       
                                       
                                          x
                                          y
                                       
                                    
                                    +
                                    (
                                    
                                       
                                          I
                                       
                                       
                                          y
                                       
                                    
                                    –
                                    1
                                    )
                                    
                                       
                                          N
                                       
                                       
                                          x
                                       
                                    
                                    +
                                    +
                                    
                                       
                                          I
                                       
                                       
                                          x
                                       
                                    
                                    
                                    where
                                    
                                    
                                       
                                          N
                                       
                                       
                                          x
                                          y
                                       
                                    
                                    =
                                    
                                       
                                          N
                                       
                                       
                                          x
                                       
                                    
                                    
                                       
                                          N
                                       
                                       
                                          y
                                       
                                    
                                 
                              
                           Points in the cells can be fully specified by a single array A, such that points assigned to cell k are given by {A
                           
                              m
                           , m=A
                           
                              k
                           
                           +1, A
                           
                              k+1}. Whether it is a 2D grid or a 3D grid, by means of the pointer approach, the memory required for the grid construction is always a linear array A of size equal to N+N
                           
                              c
                           +1. Given a point p(x,y,z), the containing cell k is given by the same point allocation formula (
                           Fig. 12)
                              
                                 
                                    k
                                    =
                                    (
                                    
                                       
                                          I
                                       
                                       
                                          z
                                       
                                    
                                    –
                                    1
                                    )
                                    
                                       
                                          N
                                       
                                       
                                          x
                                          y
                                       
                                    
                                    +
                                    (
                                    
                                       
                                          I
                                       
                                       
                                          y
                                       
                                    
                                    –
                                    1
                                    )
                                    
                                       
                                          N
                                       
                                       
                                          x
                                       
                                    
                                    +
                                    
                                       
                                          I
                                       
                                       
                                          x
                                       
                                    
                                    ,
                                 
                              
                           where I
                           
                              x
                           
                           =[(x–x
                           
                              min
                           )/d
                           
                              x
                           ]+1, I
                           
                              y
                           
                           =[(y–y
                           
                              min
                           )/d
                           
                              y
                           ]+1, I
                           
                              z
                           
                           =[(z–z
                           
                              min
                           )/d
                           
                              z
                           ]+1.

The given set of points are partitioned into N
                           
                              c
                           =N
                           
                              x
                           
                           N
                           
                              y
                           
                           N
                           
                              z
                            cells, which are inserted one by one in a contiguous manner to reduce the searching time in locating the base tetrahedron as shown in 
                           Fig. 13 for the insertion of a layer of cells. Given a set of N points, the number of cells is approximately given by
                              
                                 
                                    
                                       
                                          N
                                       
                                       
                                          c
                                       
                                    
                                    ≈
                                    N
                                    /
                                    n
                                 
                              
                           where n is the average number of points in a cell.

There is no theoretical optimal value for n; however, from practical experience, the performance of regular grid is not very sensitive to n, which can produce satisfactory results with values ranging from 20 to 30 for various point distributions. The memory requirement for the construction of a regular grid is relatively low, and all that is needed is an integer array of size given by
                              
                                 
                                    Memory
                                    
                                    required
                                    
                                    by
                                    
                                    regular
                                    
                                    grid
                                    =
                                    Number
                                    
                                    of
                                    
                                    cells
                                    +
                                    Number
                                    
                                    of
                                    
                                    points
                                    =
                                    
                                       
                                          N
                                       
                                       
                                          c
                                       
                                    
                                    +
                                    N
                                    .
                                 
                              
                           
                        

Applying regular grid to non-uniform point distribution, the number of points within a cell can have a large variation as shown in 
                        Fig. 14. In some cells, there are more than 1000 points, whereas in other cells not even a single point is present. For evenly distributed point sets, the threshold for the application of regular grid is very low at about 100 points, i.e. the CPU time will be reduced for the insertion of any reasonable point distributions more than 100 points by applying a regular grid compared to a direct insertion point by point in one zone.

In view of the very low threshold of about 100 points for regular insertion, efficiency of point insertion can be significantly enhanced by applying the regular grid in a recursive manner to cells containing, say more than 200 points, as shown in Fig. 14. The searching time for the location of the base tetrahedron can be tightly controlled such that there are about 10 points in each further divided cell. However, the number of conflicting tetrahedra for each point inserted is still governed by the non-uniform distribution characterized with excessive connections by elongated tetrahedra.

Presence of elongated tetrahedra is an intrinsic feature of highly non-uniform point distributions, which poses a significant difficulty over uniform point distributions. For the same number of points, much more CPU time will be needed for the triangulation of severe non-uniformly distributed point sets compared to a uniform distribution or a mildly non-uniform distribution. Nevertheless, using appropriate point insertion schemes, such as the kd-tree and the multi-grid insertions, the time for the determination of the base tetrahedron would not be much more than the case of uniform distribution.

To avoid excessive removal of closely packed elongated tetrahedra in a point insertion with points too close to each other, some separation control can be exercised by taking one point from a cell at a time instead of inserting all the points within a cell all at the same time. By doing so, as shown in many examples, the average number of conflicting tetrahedra removed for each point insertion can be substantially reduced, resulting in a more stable insertion scheme with higher overall performance.
                           
                              
                                 
                                 
                                    
                                       Pseudo-code for the recursive multi-grid insertion algorithm
                                    
                                    
                                       
                                          Multi-grid Insertion (P)
                                       
                                    
                                    
                                       //Input: A set of N point P; Output: Triangulation generated by inserting P.
                                    
                                    
                                       
                                          Create regular grid of cells 
                                          C
                                          
                                             k
                                          , k=1,Nc for 
                                          P 
                                          as described in 
                                          Section 4.1.
                                    
                                    
                                       
                                          Threshold=200
                                    
                                    
                                       
                                          Loop: k=1,Nc
                                       
                                    
                                    
                                       
                                          If (n(C
                                          
                                             k
                                          )>Threshold) Multi-grid Insertion (C
                                          
                                             k
                                          
                                          )//
                                          n(C
                                          
                                             k
                                          )=number of points in C
                                          
                                             k
                                          
                                       
                                    
                                    
                                       
                                          else
                                       
                                    
                                    
                                       
                                          Insert points in 
                                          C
                                          
                                             k
                                           
                                          by standard point insertion kernel
                                       
                                    
                                    
                                       
                                          End If
                                       
                                    
                                    
                                       
                                          End Loop k
                                       
                                    
                                 
                              
                           
                        
                     

The threshold of 200 is arbitrary, and the algorithm will also work pretty well if we set the threshold to 150 or 250. The process will always converge as a subdivided cell cannot have more than 200 points after a number of subdivisions; for instance, in three subdivisions, a cell may contain more than 2003=8,000,000 points for locally uniform distributions. Even for the most non-uniform point distributions, the level of subdivision seldom exceeds four, unless points are distributed in an exponential manner which will however easily exceed the finite precisions adopted in floating point computations. As for the memory requirement, the memory needed for each subdivision is N
                        
                           c
                        +n(C
                        
                           k
                        ), where N
                        
                           c
                         is the number of cell divisions for C
                        
                           k
                        . The memory for recursive grid subdivision will only grow in a linear manner, i.e. memory required in m subdivisions is given by 
                           M
                           =
                           
                              
                                 ∑
                              
                              
                                 i
                                 =
                                 1
                                 ,
                                 m
                              
                           
                           
                              
                                 N
                              
                              
                                 c
                              
                           
                           +
                           n
                           (
                           
                              
                                 C
                              
                              
                                 
                                    
                                       k
                                    
                                    
                                       i
                                    
                                 
                              
                           
                           )
                        , and this is roughly equal to mN
                        
                           c
                        +the total number of points in the cell under consideration. As the points in a cell is a subset of P, we must have M<N.

Six different distributions, random, line, diagonal, ellipse, spiral and cluster of 0.4–20 million points as shown in 
                     
                     
                     
                     
                     
                     Figs. 15–20 were triangulated using the regular grid insertion, the enhanced kd-tree insertion and the multi-grid insertion on a PC, Intel®, Core™, i7 CPU, 870@2.93GHz with 16GB RAM running on Window 7 using Intel Fortran VS2010 on 64bit. Mild non-uniform point distributions of line pattern is shown in Fig. 16, in which the width is about 1% of the larger dimension, and the cluster distribution is generated with random points biased towards the centre with radius r shortened by
                        
                           (1)
                           
                              r
                              =
                              
                                 
                                    r
                                 
                                 
                                    0
                                 
                              
                              ×
                              r
                              a
                              n
                              d
                              o
                              m
                              _
                              n
                              u
                              m
                              b
                              e
                              
                                 
                                    r
                                 
                                 
                                    3
                                    −
                                    5
                                 
                              
                           
                        
                     The random point distribution and the other five mild non-uniform point distributions of 1 million points were triangulated by the regular grid insertion scheme.

It is found that the CPU times taken for the insertion of 1 million mild non-uniform distributions were not much higher than that of the uniform distribution as shown in 
                     Table 1 and 
                     Fig. 21. In view of this situation, in the tests for the three insertion schemes, more severe non-uniform point distributions were adopted, in which the width of point spread was narrowed down to 0.01% as shown in Figs. 15 and 17 and the cluster distribution was generated using a power of 5 instead of 3 in Eq. (1).

The results for the insertion of the highly non-uniform point distributions are shown in 
                     
                     
                     
                     
                     
                     Tables 2–7 for various distribution patterns, whereas the corresponding plots of CPU time against the number of points inserted are depicted in 
                     
                     
                     
                     
                     
                     Figs. 22–27.

For uniform point distribution, the number of points in a cell is roughly equal to the number of points specified in a cell, and the multi-grid insertion was not invoked as the threshold of 200 points was never exceeded. Thus, the results for regular grid and multi-grid are identical for the insertion of 0.4–20 million points. The average number of tetrahedra visited for the location of the base, NP was very steady at 7.5, and the average number of conflicting tetrahedra removed in the creation of the insertion cavity, NR was about 27 showing that local characteristics of randomly generated points do not change with the total number of points in the set. For the insertion of 2 million points 17s was required, which increased to 170s for the insertion of 20 million points, a strict linear time relationship for a 10-fold increase of points.

As points are well-sorted in the kd-tree insertion, the base searching time as indicated by NP≈7.7 is similar to that of the regular grid insertion. However, the number of tetrahedra removed, NR=29, is slightly larger than that of the regular insertion, resulting in an equally fast insertion scheme relative to the regular grid insertion. Nevertheless, if the grid construction time is also taken into account, the total CPU time of kd-tree insertion is always higher than that of the regular grid insertion scheme. This gap widened with the number of point increased, as the time complexity of kd-tree is of order O(n
                     log
                     n). For the insertion of 20 million points, the construction of kd-tree alone took 84.2s, which is already half of the total CPU time of 171.1s for the regular grid insertion.

There is a great difference between regular grid insertion and multi-grid insertion for points concentrated along a straight line as shown in Table 2. The main cause for such a large discrepancy is due to the time taken for the location of the base tetrahedron; NP for regular grid was more than 200 and NP for multiple-grid varied from 20 to 30, resulting in a 4-time difference in the insertion time. NP=9 for kd-tree insertion is the smallest for the three insertion schemes. However, the NR value of kd-tree is double of that of the regular grid insertion or the multi-grid insertion, resulting in a slightly more efficient insertion scheme. However, if the grid construction time is also taken into consideration, the total CPU time of the kd-tree scheme is just about the same compared to the multi-grid insertion scheme.

The diagonal distribution was the first major challenge for the various insertion schemes. With a similar NR value, NP=150 of the regular grid insertion is much higher than NP=25 of the multi-grid insertion, leading to about 3 time difference in the overall performance. As for the kd-tree insertion, with NP value of 9.5 and NR value of 35, excluding the grid construction time, the insertion time is slightly less than that of the multi-grid insertion for the insertion of 20 million points.

As points are fairly evenly spread over the ellipsoidal surface, the performance of the three insertion scheme is roughly the same for the ellipse distribution. It is interesting to note that the CPU time taken for the ellipse distribution is even less than that of the uniform random distribution for the insertion of 0.4–20 million points. A possible cause for this to happen is that the average number of points in a cell for the ellipse distribution is closer to the optimal number of insertion (20–30) compared to the case of uniform distribution, in which the specified number of points in a cell had been set equal to 8.

The spiral distribution was another difficult case for various point insertion schemes. The NP value of 160 for the regular insertion is much higher compared to the uniform distribution, resulting in a 3 time increase of CPU time for the insertion of 2 million points. With reference to uniform distribution, the NP values for multi-grid insertion increased only slightly from 7.5 to 20, resulting in a slight increase of CPU time from 170s to 237s for the insertion of 20 million points. Although there is not much difference in the overall performance of the kd-tree insertion with a small NP value of 10 but a large NR value of 43, it is appreciably slower than the multi-grid insertion if the grid construction time is also taken into consideration.

A cluster distribution is locally very similar to the uniform distribution and not many elongated tetrahedra are expected in the triangulation. As points are drastically unevenly distributed, the NP value for regular grid insertion was pretty high, which increased steadily with the number of points inserted up to more than 50 for a cluster of 2 million points, and as a result the regular grid insertion took 50% more CPU time compared to uniform distribution. On the other hand, the multi-grid and the kd-tree insertions both recorded an excellent performance of a marginal increase of CPU time relative to what is needed for the uniform distribution. Nevertheless, the performance of the multi-grid insertion is still the best overall if grid construction is taken into account.

Apart from the number of points inserted, the impact of various non-uniform point distributions for the three insertion schemes has also been studied. A faster PC Intel i7-3770 @ 3.40GHz with 32GB and 64bit operating system has been used for the test runs of large point sets. The CPU times for various distribution patterns by the insertion schemes for the insertion of 10 million and 20 million points are plotted respectively in 
                     
                     Figs. 28 and 29. As shown from the graphs, regular grid insertion took much more CPU time for non-uniform point distributions compared to uniform distributions, whereas both the kd-tree insertion and the multi-grid insertion could substantially reduce the CPU time taken for point sets of non-uniform distributions as large as 20 million points. The general performance of CGAL4.2 is slightly better than that of kd-tree insertion; however it is still about 10% slower on the average compared to multi-grid insertion.

One more difficult point distribution in the pattern of galaxy in which there is vast empty space between clusters is considered as shown in 
                     Fig. 30. Two tests with a total of 3 million and 6 million points respectively were triangulated by the regular grid insertion, the multi-grid insertion and the enhanced kd-tree insertion. As shown in 
                     Table 8, more or less the same results are obtained as for the other non-uniform point distributions, in which the regular grid insertion took three times more CPU time compared to the multi-grid insertion, as the path for the search of the base tetrahedron was substantially longer. Again, the multi-grid insertion is the most efficient among the three insertion schemes if the grid generation time is also taken into consideration.

As mentioned in Section 1.4, the performance of the point insertion algorithm is related to how fast the base tetrahedron is located and how many non-Delaunay tetrahedra have to be removed for each point insertion. The time complexity of the point insertion algorithm depends, therefore, not only on the insertion method employed but also on the distribution and the characteristics of the point set. The primary purpose of the multi-grid insertion is to allocate an optimal number of points within a cell (controlled space) so as to speed up the search for the base tetrahedron, while the random order of the points within a cell is maintained to avoid excessive removal of non-Delaunay tetrahedra for the insertion of neighbouring points. In this respect, the multi-grid insertion is very successful in speeding up the search for the base tetrahedra without increasing the number of non-Delaunay tetrahedra to be removed as in the case of kd-tree partition due to over sorting.

In the light of the numerical examples done, we can see that the path for the search of the base tetrahedron in the regular grid insertion increases rapidly with the non-uniformity of the points from 7.5 for uniformly distributed points to more than 200 for a line distribution as pointed tetrahedra connecting points far apart are created as shown in Fig. 5. With the introduction of the multi-grid insertion scheme, the path for the line distribution is cut down to 30 or less. The path can be further reduced by means of the kd-tree partition; however, the price to pay is an increase in the number of non-Delaunay tetrahedra to be removed for each point insertion as points are so close to each other in a kd-tree partition, resulting in a more or less equally efficient insertion scheme without counting the grid construction time. It is an open question whether we could reduce the path to the level of that of the kd-tree without increasing the non-Delaunay tetrahedra to be removed for each point insertion. Nevertheless, the spiral and the galaxy point distributions may be among the worst cases as tetrahedra are connected to boundary points; but then even in these difficult cases, the CPU time needed is less than twice for that of a uniform point distribution by the multi-grid insertion algorithm.

The enhanced kd-tree insertion and the multi-grid have been applied to two practical examples of adaptive mesh refinement as shown in 
                     
                     Figs. 31 and 32. The first practical example is a machine part of 256403 tetrahedral elements and 54,924 nodes, which was refined by adding more nodes within a relatively small part of the object, and as a result, a total of 3,318,541 nodes were inserted and 19,653,929 tetrahedral elements were constructed as shown in 
                     Table 9. The second practical example is a finite element model of a church consisting of 192,196 nodes and 772,140 tetrahedral elements. The mesh was refined by adding more nodes to the interior of the mesh rather locally to within a small region, and the final mesh consists of 4,824,332 nodes and 28,631,864 tetrahedral elements.

As expected, the gradual nodal spacing variation within an adaptive finite element mesh is very similar to the case of mild non-uniform point distributions, and about 1 million points are inserted in 10s. The performance of the three insertion schemes, namely, the regular grid insertion, the multiple grid insertion and the kd-tree insertion are more or less the same. As the number of cells is of the same order of the points, for a smooth variation of nodal spacing over refinement meshes, some cells may contain up to only a hundred times of the average number of points in a cell. This slight variation in the number of points within cells, less than 1000, would not have much impact in the time for triangulation. Moreover, the nodal distribution of a finite element mesh is less drastic compared to the benchmark non-uniform point distributions such as cross and spiral with a narrow spread of 0.01%, in such a way that much fewer pointed and narrow tetrahedra are formed which indeed locally resemble a mesh of uniform point distribution.

By means of a regular grid, the parallel Delaunay triangulation by zonal insertion can be applied to mild non-uniform point distribution or point distribution with a gradual change of nodal spacing arising from adaptive meshing, [5]. The 2×2×2 zonal parallel insertion has been applied to non-uniform point distributions, in which 5 million points were randomly generated superimposed with another 5 million points generated respectively along the diagonals, over the surface of a sphere and on a spiral curve as shown in 
                     
                     
                     Figs. 33–35. These point distributions have been designed to simulate practical case of adaptive refinement meshing of a large number of points, with local concentration in solid and fluid mechanics problems. The CPU times in seconds on a PC, Intel®, Core™, i7 CPU, 870@2.93GHz with 16GB for single-processor insertion and multi-processor insertion are shown in 
                     Table 10.

For highly non-uniform point distributions with point concentration within a region of 0.01% of the larger dimension, the multi-grid insertion could be applied. As the multi-grid is a just regular grid on top of another regular grid, the parallel insertion designed for regular grid can also be applied to multi-grid insertion. However, it is more difficult for the parallelization of kd-tree insertion, as the cells of a kd-tree partition is not in alignment going from one cell to the adjacent cells.

The fundamentals for the Delaunay triangulations of non-uniformly distributed points by the insertion method are discussed. In the light of the simplicity and linearity of regular grid insertion, a multi-grid insertion scheme is proposed for the triangulation of uniform and non-uniform point distributions by recursive application of the regular grid insertion to an arbitrary subset of the original point set.

The performance of all the insertion schemes, namely, the regular grid, the multi-grid and the enhanced kd-tree is quite promising, in which only the regular grid insertion showed a poor performance for the line and the spiral distributions. The regular grid insertion is very sensitive to point distribution concentrated along a curve or towards a point, as the time taken in searching for the base tetrahedron increases rapidly with highly non-uniformly distributed points.

Excellent performance of the multi-grid and the enhanced kd-tree insertions is observed for large highly non-uniformly distributed point sets, such that the CPU time taken is no more than double of that of a uniform distribution for the insertion of 20 million points. Compared to the multi-grid insertion, the NP value of kd-tree insertion is usually smaller but this is often offset by a larger NR value for triangulations characterized with a large amount of elongated tetrahedra, resulting in a similar overall performance for the two schemes.

The multi-grid insertion is the most efficient and stable for all the distribution patterns tested among the three insertion schemes if the grid construction time is also taken into account. A quasi-linear complexity can be observed for the triangulation of distribution patterns with local features similar to those of a uniform point distribution, such as line, ellipse and cluster, etc. However, a bit more CPU time is needed for the triangulation of more difficult distribution patterns, such as diagonal and spiral, in which there are many elongated tetrahedra in the triangulation leading to a slightly nonlinear complexity. Nevertheless, with the multi-grid insertion, the triangulation time of the worst non-uniform distribution of 20 million points tested is about only 60% more than that of a uniform distribution, which is already a couple of times faster than existing triangulation schemes.

@&#ACKNOWLEDGEMENTS@&#

The financial support from the HKSAR GRF Grant to the research project HKU715110E on “Drifted based seismic fragility analysis of high-rise RC buildings with transfer structures” is greatly acknowledged.

@&#REFERENCES@&#

